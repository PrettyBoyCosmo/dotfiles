/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@tgrosinger/md-advanced-tables/lib/point.js
var require_point = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/point.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Point = void 0;
    var Point2 = class {
      /**
       * Creates a new `Point` object.
       *
       * @param row - Row of the point, starts from 0.
       * @param column - Column of the point, starts from 0.
       */
      constructor(row, column) {
        this.row = row;
        this.column = column;
      }
      /**
       * Checks if the point is equal to another point.
       */
      equals(point) {
        return this.row === point.row && this.column === point.column;
      }
    };
    exports.Point = Point2;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/range.js
var require_range = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Range = void 0;
    var Range2 = class {
      /**
       * Creates a new `Range` object.
       *
       * @param start - The start point of the range.
       * @param end - The end point of the range.
       */
      constructor(start, end) {
        this.start = start;
        this.end = end;
      }
    };
    exports.Range = Range2;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/focus.js
var require_focus = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/focus.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Focus = void 0;
    var Focus = class _Focus {
      /**
       * Creates a new `Focus` object.
       *
       * @param row - Row of the focused cell.
       * @param column - Column of the focused cell.
       * @param offset - Raw offset in the cell.
       */
      constructor(row, column, offset) {
        this.row = row;
        this.column = column;
        this.offset = offset;
      }
      /**
       * Checks if two focuses point the same cell.
       * Offsets are ignored.
       */
      posEquals(focus) {
        return this.row === focus.row && this.column === focus.column;
      }
      /**
       * Creates a copy of the focus object by setting its row to the specified value.
       *
       * @param row - Row of the focused cell.
       * @returns A new focus object with the specified row.
       */
      setRow(row) {
        return new _Focus(row, this.column, this.offset);
      }
      /**
       * Creates a copy of the focus object by setting its column to the specified value.
       *
       * @param column - Column of the focused cell.
       * @returns A new focus object with the specified column.
       */
      setColumn(column) {
        return new _Focus(this.row, column, this.offset);
      }
      /**
       * Creates a copy of the focus object by setting its offset to the specified value.
       *
       * @param offset - Offset in the focused cell.
       * @returns A new focus object with the specified offset.
       */
      setOffset(offset) {
        return new _Focus(this.row, this.column, offset);
      }
    };
    exports.Focus = Focus;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/alignment.js
var require_alignment = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/alignment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeaderAlignment = exports.DefaultAlignment = exports.Alignment = void 0;
    var Alignment2;
    (function(Alignment3) {
      Alignment3["NONE"] = "none";
      Alignment3["LEFT"] = "left";
      Alignment3["RIGHT"] = "right";
      Alignment3["CENTER"] = "center";
    })(Alignment2 || (exports.Alignment = Alignment2 = {}));
    var DefaultAlignment;
    (function(DefaultAlignment2) {
      DefaultAlignment2["LEFT"] = "left";
      DefaultAlignment2["RIGHT"] = "right";
      DefaultAlignment2["CENTER"] = "center";
    })(DefaultAlignment || (exports.DefaultAlignment = DefaultAlignment = {}));
    var HeaderAlignment;
    (function(HeaderAlignment2) {
      HeaderAlignment2["FOLLOW"] = "follow";
      HeaderAlignment2["LEFT"] = "left";
      HeaderAlignment2["RIGHT"] = "right";
      HeaderAlignment2["CENTER"] = "center";
    })(HeaderAlignment || (exports.HeaderAlignment = HeaderAlignment = {}));
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/table-cell.js
var require_table_cell = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/table-cell.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableCell = void 0;
    var alignment_1 = require_alignment();
    var TableCell = class {
      /**
       * Creates a new `TableCell` object.
       *
       * @param rawContent - Raw content of the cell.
       */
      constructor(rawContent) {
        this.rawContent = rawContent;
        this.content = rawContent.trim();
        this.paddingLeft = this.content === "" ? this.rawContent === "" ? 0 : 1 : this.rawContent.length - this.rawContent.trimLeft().length;
        this.paddingRight = this.rawContent.length - this.content.length - this.paddingLeft;
      }
      /**
       * Convers the cell to a text representation.
       *
       * @returns The raw content of the cell.
       */
      toText() {
        return this.rawContent;
      }
      /**
       * Checks if the cell is a delimiter i.e. it only contains hyphens `-` with optional one
       * leading and trailing colons `:`.
       *
       * @returns `true` if the cell is a delimiter.
       */
      isDelimiter() {
        return /^\s*:?-+:?\s*$/.test(this.rawContent);
      }
      /**
       * Returns the alignment the cell represents.
       *
       * @returns The alignment the cell represents; `undefined` if the cell is not a delimiter.
       */
      getAlignment() {
        if (!this.isDelimiter()) {
          return void 0;
        }
        if (this.content[0] === ":") {
          if (this.content[this.content.length - 1] === ":") {
            return alignment_1.Alignment.CENTER;
          }
          return alignment_1.Alignment.LEFT;
        }
        if (this.content[this.content.length - 1] === ":") {
          return alignment_1.Alignment.RIGHT;
        }
        return alignment_1.Alignment.NONE;
      }
      /**
       * Computes a relative position in the trimmed content from that in the raw content.
       *
       * @param rawOffset - Relative position in the raw content.
       * @returns - Relative position in the trimmed content.
       */
      computeContentOffset(rawOffset) {
        if (this.content === "") {
          return 0;
        }
        if (rawOffset < this.paddingLeft) {
          return 0;
        }
        if (rawOffset < this.paddingLeft + this.content.length) {
          return rawOffset - this.paddingLeft;
        }
        return this.content.length;
      }
      /**
       * Computes a relative position in the raw content from that in the trimmed content.
       *
       * @param contentOffset - Relative position in the trimmed content.
       * @returns - Relative position in the raw content.
       */
      computeRawOffset(contentOffset) {
        return contentOffset + this.paddingLeft;
      }
    };
    exports.TableCell = TableCell;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/table-row.js
var require_table_row = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/table-row.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableRow = void 0;
    var table_cell_1 = require_table_cell();
    var TableRow = class _TableRow {
      /**
       * Creates a new `TableRow` objec.
       *
       * @param cells - Cells that the row contains.
       * @param marginLeft - Margin string at the left of the row.
       * @param marginRight - Margin string at the right of the row.
       */
      constructor(cells, marginLeft, marginRight) {
        this._cells = cells.slice();
        this.marginLeft = marginLeft;
        this.marginRight = marginRight;
      }
      /**
       * Gets the number of the cells in the row.
       */
      getWidth() {
        return this._cells.length;
      }
      /**
       * Returns the cells that the row contains.
       */
      getCells() {
        return this._cells.slice();
      }
      /**
       * Gets a cell at the specified index.
       *
       * @param index - Index.
       * @returns The cell at the specified index if exists; `undefined` if no cell is found.
       */
      getCellAt(index) {
        return this._cells[index];
      }
      /**
       * Sets a cell in the row to a new value, returning a copy of the row
       * with the modified value.
       *
       * If an invalid index is provided, the row will be unchanged.
       */
      setCellAt(index, value) {
        const cells = this.getCells();
        cells[index] = new table_cell_1.TableCell(value);
        return new _TableRow(cells, this.marginLeft, this.marginRight);
      }
      /**
       * Convers the row to a text representation.
       */
      toText() {
        if (this._cells.length === 0) {
          return this.marginLeft;
        }
        const cells = this._cells.map((cell) => cell.toText()).join("|");
        return `${this.marginLeft}|${cells}|${this.marginRight}`;
      }
      /**
       * Checks if the row is a delimiter or not.
       *
       * @returns `true` if the row is a delimiter i.e. all the cells contained are delimiters.
       */
      isDelimiter() {
        return this._cells.every((cell) => cell.isDelimiter());
      }
    };
    exports.TableRow = TableRow;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/neverthrow/neverthrow.js
var require_neverthrow = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/neverthrow/neverthrow.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Err = exports.Ok = exports.err = exports.ok = void 0;
    var ok = (value) => new Ok(value);
    exports.ok = ok;
    var err = (err2) => new Err(err2);
    exports.err = err;
    var Ok = class {
      constructor(value) {
        this.value = value;
        this.match = (ok2, _err) => ok2(this.value);
      }
      isOk() {
        return true;
      }
      isErr() {
        return !this.isOk();
      }
      map(f) {
        return (0, exports.ok)(f(this.value));
      }
      mapErr(_f) {
        return (0, exports.ok)(this.value);
      }
      // add info on how this is really useful for converting a
      // Result<Result<T, E2>, E1>
      // into a Result<T, E2>
      andThen(f) {
        return f(this.value);
      }
      unwrapOr(_v) {
        return this.value;
      }
      _unsafeUnwrap() {
        return this.value;
      }
      _unsafeUnwrapErr() {
        throw new Error("Called `_unsafeUnwrapErr` on an Ok");
      }
    };
    exports.Ok = Ok;
    var Err = class {
      constructor(error) {
        this.error = error;
        this.match = (_ok, err2) => err2(this.error);
      }
      isOk() {
        return false;
      }
      isErr() {
        return !this.isOk();
      }
      map(_f) {
        return (0, exports.err)(this.error);
      }
      mapErr(f) {
        return (0, exports.err)(f(this.error));
      }
      andThen(_f) {
        return (0, exports.err)(this.error);
      }
      unwrapOr(v) {
        return v;
      }
      _unsafeUnwrap() {
        throw new Error("Called `_unsafeUnwrap` on an Err");
      }
      _unsafeUnwrapErr() {
        return this.error;
      }
    };
    exports.Err = Err;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/ast_utils.js
var require_ast_utils = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/ast_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prettyPrintAST = exports.checkChildLength = exports.checkType = exports.errRelativeReferenceIndex = exports.errIndex0 = void 0;
    exports.errIndex0 = new Error("Index 0 used to create a reference");
    exports.errRelativeReferenceIndex = new Error("Can not use relative reference where absolute reference is required");
    var checkType = (ast, ...expectedTypes) => {
      if (expectedTypes.indexOf(ast.type) >= 0) {
        return;
      }
      return new Error(`Formula element '${ast.text}' is a ${ast.type} but expected one of ${expectedTypes} in this position.`);
    };
    exports.checkType = checkType;
    var checkChildLength = (ast, len) => {
      if (ast.children.length === len) {
        return;
      }
      return new Error(`Formula element '${ast.text}' was expected to have ${len} elements, but had ${ast.children.length}`);
    };
    exports.checkChildLength = checkChildLength;
    var prettyPrintAST = (token, level = 0) => {
      console.log("  ".repeat(level) + `|-${token.type}${token.children.length === 0 ? "=" + token.text : ""}`);
      if (token.children) {
        token.children.forEach((c) => {
          (0, exports.prettyPrintAST)(c, level + 1);
        });
      }
    };
    exports.prettyPrintAST = prettyPrintAST;
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports, module2) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
      P.absoluteValue = P.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };
      P.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P.clampedTo = P.clamp = function(min2, max2) {
        var k, x = this, Ctor = x.constructor;
        min2 = new Ctor(min2);
        max2 = new Ctor(max2);
        if (!min2.s || !max2.s) return new Ctor(NaN);
        if (min2.gt(max2)) throw Error(invalidArgument + max2);
        k = x.cmp(min2);
        return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
      };
      P.comparedTo = P.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys) return xs;
        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P.cosine = P.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d) return new Ctor(NaN);
        if (!x.d[0]) return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P.cubeRoot = P.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.decimalPlaces = P.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) n--;
          if (n < 0) n = 0;
        }
        return n;
      };
      P.dividedBy = P.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P.dividedToIntegerBy = P.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P.equals = P.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P.greaterThan = P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.greaterThanOrEqualTo = P.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P.hyperbolicCosine = P.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.hyperbolicSine = P.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P.hyperbolicTangent = P.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P.inverseCosine = P.acos = function() {
        var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      P.inverseHyperbolicCosine = P.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicSine = P.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicTangent = P.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P.inverseSine = P.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero()) return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P.inverseTangent = P.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
        }
        if (k) r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.isFinite = function() {
        return !!this.d;
      };
      P.isInteger = P.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = P.isNeg = function() {
        return this.s < 0;
      };
      P.isPositive = P.isPos = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P.lessThan = P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lessThanOrEqualTo = P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.logarithm = P.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; ) k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P.minus = P.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (x.d) y.s = -y.s;
          else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0]) y.s = -y.s;
          else if (xd[0]) y = new Ctor(x);
          else return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; ) d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; ) xd.pop();
        for (; xd[0] === 0; xd.shift()) --e;
        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.modulo = P.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P.naturalExponential = P.exp = function() {
        return naturalExponential(this);
      };
      P.naturalLogarithm = P.ln = function() {
        return naturalLogarithm(this);
      };
      P.negated = P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P.plus = P.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0]) y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; ) d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; ) xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.precision = P.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P.sine = P.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.tangent = P.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P.times = P.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; ) r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; ) r.pop();
        if (carry) ++e;
        else r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P.toDecimalPlaces = P.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0) return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd) return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P.toHexadecimal = P.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d) return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d) return y.s ? x : y;
          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P.toNumber = function() {
        return +this;
      };
      P.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P.toPower = P.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1)) return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1)) return finalise(x, pr, rm);
        e = mathfloor(y.e / LOG_BASE);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1) return new Ctor(NaN);
          if ((y.d[e] & 1) == 0) s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toSignificantDigits = P.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.truncated = P.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P.valueOf = P.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; ) w /= 10;
        return str + w;
      }
      function checkInt32(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument + i);
        }
      }
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10) --i;
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;
            else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1e3 | 0;
            else if (i == 1) rd = rd / 100 | 0;
            else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, len, y;
        if (x.isZero()) return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry) x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; ) a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign2);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++) ;
          if (yd[i] > (xd[i] || 0)) e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; ) rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2) ++yd0;
              do {
                k = 0;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base) k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0]) qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
            q.e = i + e * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out: if (sd != null) {
          xd = x.d;
          if (!xd) return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; ) xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10) digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10) k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; ) xd.pop();
        }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k, e = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str = "0." + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE; w >= 10; w /= 10) e++;
        return e;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits) {
        var w = digits.length - 1, len = w * LOG_BASE + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10) len--;
          for (w = digits[0]; w >= 10; w /= 10) len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; ) zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, ltgt) {
        var y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum2 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = finalise(pow2.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum2.plus(divide(pow2, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            j = k;
            while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow2 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            sum2 = sum2.times(2);
            if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
            sum2 = divide(sum2, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; ) str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal.test(str)) return parseDecimal(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i) xd.pop();
        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat) x = divide(x, divisor, len * 4);
        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; ) ;
            if (j == -1) break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e) {
        var n = b;
        while (--e) n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; ) xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++) str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len) ;
                  for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; ) str = "0" + str;
              str = "0." + str;
            } else {
              if (++e > len) for (e -= len; e--; ) str += "0";
              else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs(x) {
        return new this(x).abs();
      }
      function acos(x) {
        return new this(x).acos();
      }
      function acosh(x) {
        return new this(x).acosh();
      }
      function add(x, y) {
        return new this(x).plus(y);
      }
      function asin(x) {
        return new this(x).asin();
      }
      function asinh(x) {
        return new this(x).asinh();
      }
      function atan(x) {
        return new this(x).atan();
      }
      function atanh(x) {
        return new this(x).atanh();
      }
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt(x) {
        return new this(x).cbrt();
      }
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function clamp(x, min2, max2) {
        return new this(x).clamp(min2, max2);
      }
      function config(obj) {
        if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos(x) {
        return new this(x).cos();
      }
      function cosh(x) {
        return new this(x).cosh();
      }
      function clone(obj) {
        var i, p, ps;
        function Decimal2(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal2)) return new Decimal2(v);
          x.constructor = Decimal2;
          if (isDecimalInstance(v)) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
              if (external) {
                if (e > Decimal2.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal2.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            } else if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          } else if (t !== "string") {
            throw Error(invalidArgument + v);
          }
          if ((i2 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i2 === 43) v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        Decimal2.prototype = P;
        Decimal2.ROUND_UP = 0;
        Decimal2.ROUND_DOWN = 1;
        Decimal2.ROUND_CEIL = 2;
        Decimal2.ROUND_FLOOR = 3;
        Decimal2.ROUND_HALF_UP = 4;
        Decimal2.ROUND_HALF_DOWN = 5;
        Decimal2.ROUND_HALF_EVEN = 6;
        Decimal2.ROUND_HALF_CEIL = 7;
        Decimal2.ROUND_HALF_FLOOR = 8;
        Decimal2.EUCLID = 9;
        Decimal2.config = Decimal2.set = config;
        Decimal2.clone = clone;
        Decimal2.isDecimal = isDecimalInstance;
        Decimal2.abs = abs;
        Decimal2.acos = acos;
        Decimal2.acosh = acosh;
        Decimal2.add = add;
        Decimal2.asin = asin;
        Decimal2.asinh = asinh;
        Decimal2.atan = atan;
        Decimal2.atanh = atanh;
        Decimal2.atan2 = atan2;
        Decimal2.cbrt = cbrt;
        Decimal2.ceil = ceil;
        Decimal2.clamp = clamp;
        Decimal2.cos = cos;
        Decimal2.cosh = cosh;
        Decimal2.div = div;
        Decimal2.exp = exp;
        Decimal2.floor = floor;
        Decimal2.hypot = hypot;
        Decimal2.ln = ln;
        Decimal2.log = log;
        Decimal2.log10 = log10;
        Decimal2.log2 = log2;
        Decimal2.max = max;
        Decimal2.min = min;
        Decimal2.mod = mod;
        Decimal2.mul = mul;
        Decimal2.pow = pow;
        Decimal2.random = random;
        Decimal2.round = round;
        Decimal2.sign = sign;
        Decimal2.sin = sin;
        Decimal2.sinh = sinh;
        Decimal2.sqrt = sqrt;
        Decimal2.sub = sub;
        Decimal2.sum = sum;
        Decimal2.tan = tan;
        Decimal2.tanh = tanh;
        Decimal2.trunc = trunc;
        if (obj === void 0) obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
          }
        }
        Decimal2.config(obj);
        return Decimal2;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp(x) {
        return new this(x).exp();
      }
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot() {
        var i, n, t = new this(0);
        external = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log(x, y) {
        return new this(x).log(y);
      }
      function log2(x) {
        return new this(x).log(2);
      }
      function log10(x) {
        return new this(x).log(10);
      }
      function max() {
        return maxOrMin(this, arguments, "lt");
      }
      function min() {
        return maxOrMin(this, arguments, "gt");
      }
      function mod(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow(x, y) {
        return new this(x).pow(y);
      }
      function random(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0) sd = this.precision;
        else checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--) rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
          if (k < LOG_BASE) e -= LOG_BASE - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin(x) {
        return new this(x).sin();
      }
      function sinh(x) {
        return new this(x).sinh();
      }
      function sqrt(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function sum() {
        var i = 0, args = arguments, x = new this(args[i]);
        external = false;
        for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
        external = true;
        return finalise(x, this.precision, this.rounding);
      }
      function tan(x) {
        return new this(x).tan();
      }
      function tanh(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal = clone(DEFAULTS);
      Decimal.prototype.constructor = Decimal;
      Decimal["default"] = Decimal.Decimal = Decimal;
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
          P[Symbol.toStringTag] = "Decimal";
        }
        module2.exports = Decimal;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal;
        };
        globalScope.Decimal = Decimal;
      }
    })(exports);
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/results.js
var require_results = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/results.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Value = exports.Arity = exports.FloatOrMilliseconds = void 0;
    var decimal_js_1 = __importDefault(require_decimal());
    var lodash_1 = require_lodash();
    var datetimeRe = new RegExp("[1-9][0-9]{3}-[01][0-9]-[0-3][0-9][T ][0-2][0-9]:[0-5][0-9]");
    var durationRe = new RegExp("^-?[0-9]+:[0-5][0-9]");
    var FloatOrMilliseconds = (value) => {
      const v = value.trim();
      if (v === "") {
        return new decimal_js_1.default(0);
      }
      if (datetimeRe.test(v)) {
        return new decimal_js_1.default(new Date(v).valueOf());
      }
      if (durationRe.test(v)) {
        const neg = v.charAt(0) == "-";
        const w = v.slice(neg ? 1 : 0);
        const minutes = parseInt(w.slice(0, -3)) * 60 + parseInt(w.slice(-2));
        return new decimal_js_1.default((neg ? -1 : 1) * minutes * 6e4);
      }
      const decimalValue = new decimal_js_1.default(v);
      return decimalValue.isNaN() ? new decimal_js_1.default(0) : decimalValue;
    };
    exports.FloatOrMilliseconds = FloatOrMilliseconds;
    var Arity = class {
      constructor(rows, columns) {
        this.isRow = () => this.rows > 1 && this.cols === 1;
        this.isColumn = () => this.rows === 1 && this.cols > 1;
        this.isCell = () => this.rows === 1 && this.cols === 1;
        this.rows = rows;
        this.cols = columns;
      }
    };
    exports.Arity = Arity;
    var Value = class {
      constructor(val) {
        this.get = (row, column) => this.val[row][column];
        this.getAsNumber = (row, column) => {
          const value = this.get(row, column);
          return (0, exports.FloatOrMilliseconds)(value);
        };
        this.getArity = () => {
          const maxCols = this.val.reduce((max, currentRow) => Math.max(max, currentRow.length), 0);
          return new Arity(this.val.length, maxCols);
        };
        this.toString = () => {
          if (this.getArity().isCell()) {
            return this.get(0, 0);
          }
          return `[${(0, lodash_1.flatten)(this.val).map((val2) => val2.trim()).filter((val2) => val2 !== "").join(", ")}]`;
        };
        this.val = val;
      }
    };
    exports.Value = Value;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/algebraic_operation.js
var require_algebraic_operation = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/algebraic_operation.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlgebraicOperation = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var calc_1 = require_calc();
    var results_1 = require_results();
    var lodash_1 = require_lodash();
    var AlgebraicOperation = class {
      constructor(ast, table) {
        this.getValue = (table2, cell) => {
          switch (this.operator) {
            case "+":
              return this.add(table2, cell);
            case "-":
              return this.subtract(table2, cell);
            case "*":
              return this.multiply(table2, cell);
            case "/":
              return this.divide(table2, cell);
            default:
              return (0, neverthrow_1.err)(Error("Invalid algbraic operator: " + this.operator));
          }
        };
        this.withCellAndRange = (table2, cell, name, canHaveRightRange, fn) => {
          const leftValue = this.leftSource.getValue(table2, cell);
          if (leftValue.isErr()) {
            return (0, neverthrow_1.err)(leftValue.error);
          }
          const rightValue = this.rightSource.getValue(table2, cell);
          if (rightValue.isErr()) {
            return (0, neverthrow_1.err)(rightValue.error);
          }
          const leftArity = leftValue.value.getArity();
          const rightArity = rightValue.value.getArity();
          if (!rightArity.isCell() && !leftArity.isCell()) {
            return (0, neverthrow_1.err)(Error(`At least one operand in algebraic "${name}" must be a single cell.`));
          }
          if (!rightArity.isCell() && !canHaveRightRange) {
            return (0, neverthrow_1.err)(Error(`Right operand in algebraic "${name}" must be a single cell.`));
          }
          if (rightArity.isCell()) {
            const rightCellValue = rightValue.value.getAsNumber(0, 0);
            const result2 = (0, lodash_1.map)(leftValue.value.val, (currentRow) => (0, lodash_1.map)(currentRow, (currentCell) => {
              const leftCellValue2 = (0, results_1.FloatOrMilliseconds)(currentCell);
              return fn(leftCellValue2, rightCellValue).toString();
            }));
            return (0, neverthrow_1.ok)(new results_1.Value(result2));
          }
          const leftCellValue = leftValue.value.getAsNumber(0, 0);
          const result = (0, lodash_1.map)(rightValue.value.val, (currentRow) => (0, lodash_1.map)(currentRow, (currentCell) => {
            const rightCellValue = (0, results_1.FloatOrMilliseconds)(currentCell);
            return fn(leftCellValue, rightCellValue).toString();
          }));
          return (0, neverthrow_1.ok)(new results_1.Value(result));
        };
        this.add = (table2, cell) => this.withCellAndRange(table2, cell, "add", true, (left, right) => left.plus(right));
        this.subtract = (table2, cell) => this.withCellAndRange(table2, cell, "subtract", true, (left, right) => left.minus(right));
        this.multiply = (table2, cell) => this.withCellAndRange(table2, cell, "multiply", true, (left, right) => left.times(right));
        this.divide = (table2, cell) => this.withCellAndRange(table2, cell, "divide", false, (left, right) => left.dividedBy(right));
        const typeErr = (0, ast_utils_1.checkType)(ast, "algebraic_operation");
        if (typeErr) {
          throw typeErr;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 3);
        if (lengthError) {
          throw lengthError;
        }
        const childTypeErr = (0, ast_utils_1.checkType)(ast.children[1], "algebraic_operator");
        if (childTypeErr) {
          throw childTypeErr;
        }
        this.operator = ast.children[1].text;
        try {
          this.leftSource = new calc_1.Source(ast.children[0], table);
          this.rightSource = new calc_1.Source(ast.children[2], table);
        } catch (error) {
          throw error;
        }
      }
    };
    exports.AlgebraicOperation = AlgebraicOperation;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/conditional_function.js
var require_conditional_function = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/conditional_function.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConditionalFunctionCall = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var calc_1 = require_calc();
    var ConditionalFunctionCall = class {
      constructor(ast, table) {
        this.getValue = (table2, cell) => this.predicate.eval(table2, cell).andThen((predicateResult) => predicateResult ? this.leftSource.getValue(table2, cell) : this.rightSource.getValue(table2, cell));
        const typeError = (0, ast_utils_1.checkType)(ast, "conditional_function_call");
        if (typeError) {
          throw typeError;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 3);
        if (lengthError) {
          throw lengthError;
        }
        try {
          this.predicate = new Predicate(ast.children[0], table);
          this.leftSource = new calc_1.Source(ast.children[1], table);
          this.rightSource = new calc_1.Source(ast.children[2], table);
        } catch (error) {
          throw error;
        }
      }
    };
    exports.ConditionalFunctionCall = ConditionalFunctionCall;
    var Predicate = class {
      constructor(ast, table) {
        this.eval = (table2, cell) => {
          const leftData = this.leftSource.getValue(table2, cell);
          if (leftData.isErr()) {
            return (0, neverthrow_1.err)(leftData.error);
          }
          const rightData = this.rightSource.getValue(table2, cell);
          if (rightData.isErr()) {
            return (0, neverthrow_1.err)(rightData.error);
          }
          const leftArity = leftData.value.getArity();
          const rightArity = rightData.value.getArity();
          if (!leftArity.isCell()) {
            return (0, neverthrow_1.err)(Error("Can only use comparison operator on a single cell. Left side is not a cell."));
          }
          if (!rightArity.isCell()) {
            return (0, neverthrow_1.err)(Error("Can only use comparison operator on a single cell. Right side is not a cell."));
          }
          const leftVal = leftData.value.getAsNumber(0, 0);
          const rightVal = rightData.value.getAsNumber(0, 0);
          switch (this.operator) {
            case ">":
              return (0, neverthrow_1.ok)(leftVal.greaterThan(rightVal));
            case ">=":
              return (0, neverthrow_1.ok)(leftVal.greaterThanOrEqualTo(rightVal));
            case "<":
              return (0, neverthrow_1.ok)(leftVal.lessThan(rightVal));
            case "<=":
              return (0, neverthrow_1.ok)(leftVal.lessThanOrEqualTo(rightVal));
            case "==":
              return (0, neverthrow_1.ok)(leftVal.equals(rightVal));
            case "!=":
              return (0, neverthrow_1.ok)(!leftVal.equals(rightVal));
            default:
              return (0, neverthrow_1.err)(Error("Invalid conditional operator: " + this.operator));
          }
        };
        const typeError = (0, ast_utils_1.checkType)(ast, "predicate");
        if (typeError) {
          throw typeError;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 3);
        if (lengthError) {
          throw lengthError;
        }
        const childTypeError = (0, ast_utils_1.checkType)(ast.children[1], "conditional_operator");
        if (childTypeError) {
          throw childTypeError;
        }
        this.operator = ast.children[1].text;
        try {
          this.leftSource = new calc_1.Source(ast.children[0], table);
          this.rightSource = new calc_1.Source(ast.children[2], table);
        } catch (error) {
          throw error;
        }
      }
    };
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/constant.js
var require_constant = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/constant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Constant = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var results_1 = require_results();
    var Constant = class {
      constructor(ast, table) {
        const typeErr = (0, ast_utils_1.checkType)(ast, "real", "float");
        if (typeErr) {
          throw typeErr;
        }
        const multiplier = ast.text[0] === "-" ? -1 : 1;
        if (ast.type === "real") {
          this.value = multiplier * parseInt(ast.children[0].text);
        } else {
          this.value = multiplier * parseFloat(ast.children[0].text + "." + ast.children[1].text);
        }
      }
      getValue(table, currentCell) {
        return (0, neverthrow_1.ok)(new results_1.Value([[this.value.toString()]]));
      }
    };
    exports.Constant = Constant;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/column.js
var require_column = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/column.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbsoluteColumn = exports.Column = exports.newColumn = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var results_1 = require_results();
    var newColumn = (ast, table) => {
      try {
        switch (ast.type) {
          case "relative_column":
            return (0, neverthrow_1.ok)(new RelativeColumn(ast, table));
          case "absolute_column":
            return (0, neverthrow_1.ok)(new AbsoluteColumn(ast, table));
          default:
            return (0, neverthrow_1.err)(new Error(`Formula element '${ast.text}' is a ${ast.type} but expected an relatve_column or absolute_column in this position.`));
        }
      } catch (error) {
        return (0, neverthrow_1.err)(error);
      }
    };
    exports.newColumn = newColumn;
    var Column = class {
      constructor() {
        this.getValue = (table, currentCell) => {
          var _a;
          const val = ((_a = table.getCellAt(currentCell.row, this.getIndex(currentCell))) === null || _a === void 0 ? void 0 : _a.toText()) || "";
          return (0, neverthrow_1.ok)(new results_1.Value([[val]]));
        };
      }
    };
    exports.Column = Column;
    var RelativeColumn = class extends Column {
      constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => currentCell.column + this.offset;
        this.getAbsoluteIndex = () => (0, neverthrow_1.err)(ast_utils_1.errRelativeReferenceIndex);
        const typeError = (0, ast_utils_1.checkType)(ast, "relative_column");
        if (typeError) {
          throw typeError;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
        if (lengthError) {
          throw lengthError;
        }
        const multiplier = ast.text[1] === "-" ? -1 : 1;
        this.offset = multiplier * parseInt(ast.children[0].text);
      }
    };
    var AbsoluteColumn = class extends Column {
      constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => this.index;
        this.getAbsoluteIndex = () => (0, neverthrow_1.ok)(this.index);
        let index = -1;
        let symbol = "";
        switch (ast.children.length) {
          case 0:
            symbol = ast.text[1];
            break;
          case 1:
            const typeError = (0, ast_utils_1.checkType)(ast.children[0], "int");
            if (typeError) {
              throw (0, neverthrow_1.err)(typeError);
            }
            index = parseInt(ast.children[0].text);
            break;
          default:
            throw new Error(`Formula element '${ast.text}' is a ${ast.type} but expected a 'absolute_column' in this position.`);
        }
        switch (symbol) {
          case "":
            break;
          case "<":
            index = 1;
            break;
          case ">":
            index = table.getWidth();
            break;
          default:
            throw new Error(`Invalid column symbol '${symbol}'`);
        }
        if (index === 0) {
          throw ast_utils_1.errIndex0;
        }
        this.index = index - 1;
      }
    };
    exports.AbsoluteColumn = AbsoluteColumn;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/row.js
var require_row = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/row.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbsoluteRow = exports.Row = exports.newRow = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var results_1 = require_results();
    var newRow = (ast, table) => {
      try {
        switch (ast.type) {
          case "relative_row":
            return (0, neverthrow_1.ok)(new RelativeRow(ast, table));
          case "absolute_row":
            return (0, neverthrow_1.ok)(new AbsoluteRow(ast, table));
          default:
            return (0, neverthrow_1.err)(new Error(`Formula element '${ast.text}' is a ${ast.type} but expected an relatve_row or absolute_row  in this position.`));
        }
      } catch (error) {
        return (0, neverthrow_1.err)(error);
      }
    };
    exports.newRow = newRow;
    var Row = class {
      constructor() {
        this.getValue = (table, currentCell) => {
          var _a;
          const val = ((_a = table.getCellAt(this.getIndex(currentCell), currentCell.column)) === null || _a === void 0 ? void 0 : _a.toText()) || "";
          return (0, neverthrow_1.ok)(new results_1.Value([[val]]));
        };
      }
    };
    exports.Row = Row;
    var RelativeRow = class extends Row {
      constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => currentCell.row + this.offset;
        this.getAbsoluteIndex = () => (0, neverthrow_1.err)(ast_utils_1.errRelativeReferenceIndex);
        const typeError = (0, ast_utils_1.checkType)(ast, "relative_row");
        if (typeError) {
          throw typeError;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
        if (lengthError) {
          throw lengthError;
        }
        const multiplier = ast.text[1] === "-" ? -1 : 1;
        this.offset = multiplier * parseInt(ast.children[0].text);
      }
    };
    var AbsoluteRow = class extends Row {
      constructor(ast, table) {
        super();
        this.getIndex = (currentCell) => this.index;
        this.getAbsoluteIndex = () => (0, neverthrow_1.ok)(this.index);
        let index = -1;
        let symbol = "";
        switch (ast.children.length) {
          case 0:
            symbol = ast.text[1];
            break;
          case 1:
            const typeError = (0, ast_utils_1.checkType)(ast.children[0], "int");
            if (typeError) {
              throw (0, neverthrow_1.err)(typeError);
            }
            index = parseInt(ast.children[0].text);
            break;
          default:
            throw new Error(`Formula element '${ast.text}' is a ${ast.type} but expected a 'absolute_row' in this position.`);
        }
        switch (symbol) {
          case "":
            break;
          case "<":
            index = 1;
            break;
          case ">":
            index = table.getHeight() - 1;
            break;
          case "I":
            index = 2;
            break;
          default:
            throw new Error(`Invalid row symbol '${symbol}'`);
        }
        if (index === 0) {
          throw ast_utils_1.errIndex0;
        }
        if (index === 1) {
          this.index = 0;
        } else {
          this.index = index;
        }
      }
    };
    exports.AbsoluteRow = AbsoluteRow;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/reference.js
var require_reference = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/reference.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reference = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var column_1 = require_column();
    var results_1 = require_results();
    var row_1 = require_row();
    var Reference = class {
      constructor(ast, table) {
        this.getValue = (table2, currentCell) => {
          var _a;
          const cell = {
            row: this.row ? this.row.getIndex(currentCell) : currentCell.row,
            column: this.column ? this.column.getIndex(currentCell) : currentCell.column
          };
          const val = ((_a = table2.getCellAt(cell.row, cell.column)) === null || _a === void 0 ? void 0 : _a.toText()) || "";
          return (0, neverthrow_1.ok)(new results_1.Value([[val]]));
        };
        const typeErr = (0, ast_utils_1.checkType)(ast, "source_reference", "absolute_reference", "relative_reference");
        if (typeErr) {
          throw typeErr;
        }
        for (let i = 0; i < ast.children.length; i++) {
          const child = ast.children[i];
          switch (child.type) {
            case "relative_row":
            case "absolute_row":
              if (this.row !== void 0) {
                throw Error("Reference may only have at most 1 row, more than 1 provided");
              }
              const createdRow = (0, row_1.newRow)(child, table);
              if (createdRow.isErr()) {
                if (createdRow.error === ast_utils_1.errIndex0) {
                  break;
                }
                throw createdRow.error;
              }
              this.row = createdRow.value;
              break;
            case "relative_column":
            case "absolute_column":
              if (this.column !== void 0) {
                throw Error("Reference may only have at most 1 column, more than 1 provided");
              }
              const createdCol = (0, column_1.newColumn)(child, table);
              if (createdCol.isErr()) {
                if (createdCol.error === ast_utils_1.errIndex0) {
                  break;
                }
                throw createdCol.error;
              }
              this.column = createdCol.value;
              break;
          }
        }
      }
    };
    exports.Reference = Reference;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/range.js
var require_range2 = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/range.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Range = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var reference_1 = require_reference();
    var results_1 = require_results();
    var lodash_1 = require_lodash();
    var Range2 = class {
      constructor(ast, table) {
        this.getValue = (table2, currentCell) => {
          const startColumn = this.startColumn ? this.startColumn.getIndex(currentCell) : currentCell.column;
          const endColumn = this.endColumn ? this.endColumn.getIndex(currentCell) : startColumn;
          const startRow = this.startRow ? this.startRow.getIndex(currentCell) : currentCell.row;
          const endRow = this.endRow ? this.endRow.getIndex(currentCell) : currentCell.row;
          return (0, neverthrow_1.ok)(new results_1.Value((0, lodash_1.map)((0, lodash_1.range)(startRow, endRow + 1), (row) => (0, lodash_1.map)((0, lodash_1.range)(startColumn, endColumn + 1), (col) => {
            var _a;
            return ((_a = table2.getCellAt(row, col)) === null || _a === void 0 ? void 0 : _a.toText()) || "";
          }))));
        };
        this.asCells = () => {
          if (!this.startColumn || !this.startRow || !this.endRow) {
            return (0, neverthrow_1.err)(new Error("A range used as a desintation must define rows and cells"));
          }
          let endColumn = this.endColumn;
          if (!endColumn) {
            endColumn = this.startColumn;
          }
          const startRowIndex = this.startRow.getAbsoluteIndex();
          const endRowIndex = this.endRow.getAbsoluteIndex();
          const startColumnIndex = this.startColumn.getAbsoluteIndex();
          const endColumnIndex = endColumn.getAbsoluteIndex();
          if (startRowIndex.isErr() || endRowIndex.isErr() || startColumnIndex.isErr() || endColumnIndex.isErr()) {
            return (0, neverthrow_1.err)(new Error("A relative range can not be used in a formula destination"));
          }
          const minRow = Math.min(startRowIndex.value, endRowIndex.value);
          const maxRow = Math.max(startRowIndex.value, endRowIndex.value);
          const minColumn = Math.min(startColumnIndex.value, endColumnIndex.value);
          const maxColumn = Math.max(startColumnIndex.value, endColumnIndex.value);
          return (0, neverthrow_1.ok)((0, lodash_1.flatMap)((0, lodash_1.range)(minRow, maxRow + 1), (rowNum) => (0, lodash_1.range)(minColumn, maxColumn + 1).map((colNum) => ({ row: rowNum, column: colNum }))));
        };
        let typeErr = (0, ast_utils_1.checkType)(ast, "range");
        if (typeErr) {
          throw typeErr;
        }
        let lengthError = (0, ast_utils_1.checkChildLength)(ast, 2);
        if (lengthError) {
          throw lengthError;
        }
        const startChild = ast.children[0];
        const endChild = ast.children[1];
        typeErr = (0, ast_utils_1.checkType)(startChild, "source_reference");
        if (typeErr) {
          throw typeErr;
        }
        typeErr = (0, ast_utils_1.checkType)(endChild, "source_reference");
        if (typeErr) {
          throw typeErr;
        }
        lengthError = (0, ast_utils_1.checkChildLength)(startChild, 1);
        if (lengthError) {
          throw lengthError;
        }
        lengthError = (0, ast_utils_1.checkChildLength)(endChild, 1);
        if (lengthError) {
          throw lengthError;
        }
        const start = new reference_1.Reference(startChild.children[0], table);
        const end = new reference_1.Reference(endChild.children[0], table);
        if (start.row && !end.row || end.row && !start.row) {
          throw new Error("Range must use references of the same kind");
        }
        if (!start.row && !start.column) {
          console.log(start);
          throw new Error("Range must have a row or a column defined");
        }
        if (start.row) {
          this.startRow = start.row;
        }
        if (start.column) {
          this.startColumn = start.column;
        }
        if (end.row) {
          this.endRow = end.row;
        }
        if (end.column) {
          this.endColumn = end.column;
        } else {
          this.endColumn = start.column;
        }
      }
    };
    exports.Range = Range2;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/destination.js
var require_destination = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/destination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RangeDestination = exports.CellDestination = exports.ColumnDestination = exports.RowDestination = exports.newDestination = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var column_1 = require_column();
    var range_1 = require_range2();
    var row_1 = require_row();
    var lodash_1 = require_lodash();
    var newDestination = (ast, table, formatter) => {
      const typeErr = (0, ast_utils_1.checkType)(ast, "destination");
      if (typeErr) {
        return (0, neverthrow_1.err)(typeErr);
      }
      const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
      if (lengthError) {
        return (0, neverthrow_1.err)(lengthError);
      }
      const child = ast.children[0];
      if (child.type === "range") {
        return (0, neverthrow_1.ok)(new RangeDestination(child, table, formatter));
      }
      try {
        switch (child.children.length) {
          case 2:
            return (0, neverthrow_1.ok)(new CellDestination(child, table, formatter));
          case 1:
            const innerChild = child.children[0];
            if (innerChild.type === "absolute_row") {
              return (0, neverthrow_1.ok)(new RowDestination(child, table, formatter));
            } else if (innerChild.type === "absolute_column") {
              return (0, neverthrow_1.ok)(new ColumnDestination(child, table, formatter));
            }
          default:
            return (0, neverthrow_1.err)(new Error("Unexpected destination type " + child.type));
        }
      } catch (error) {
        if (error === ast_utils_1.errIndex0) {
          return (0, neverthrow_1.err)(new Error("Index 0 may not be used in a destination"));
        }
        return (0, neverthrow_1.err)(error);
      }
    };
    exports.newDestination = newDestination;
    var RowDestination = class {
      constructor(ast, table, formatter) {
        this.merge = (source, table2) => {
          const cells = (0, lodash_1.range)(0, table2.getWidth()).map((columnNum) => ({ row: this.row.index, column: columnNum }));
          return mergeForCells(source, table2, cells, this.formatter);
        };
        this.formatter = formatter;
        const typeErr = (0, ast_utils_1.checkType)(ast, "absolute_reference");
        if (typeErr) {
          throw typeErr;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
        if (lengthError) {
          throw lengthError;
        }
        const child = ast.children[0];
        try {
          this.row = new row_1.AbsoluteRow(child, table);
        } catch (error) {
          throw error;
        }
      }
    };
    exports.RowDestination = RowDestination;
    var ColumnDestination = class {
      constructor(ast, table, formatter) {
        this.merge = (source, table2) => {
          const cells = (0, lodash_1.range)(2, table2.getHeight()).map((rowNum) => ({ row: rowNum, column: this.column.index }));
          return mergeForCells(source, table2, cells, this.formatter);
        };
        this.formatter = formatter;
        const typeErr = (0, ast_utils_1.checkType)(ast, "absolute_reference");
        if (typeErr) {
          throw typeErr;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
        if (lengthError) {
          throw lengthError;
        }
        const child = ast.children[0];
        try {
          this.column = new column_1.AbsoluteColumn(child, table);
        } catch (error) {
          throw error;
        }
      }
    };
    exports.ColumnDestination = ColumnDestination;
    var CellDestination = class {
      constructor(ast, table, formatter) {
        this.merge = (source, table2) => {
          const cell = { row: this.row.index, column: this.column.index };
          return mergeForCells(source, table2, [cell], this.formatter);
        };
        this.formatter = formatter;
        const typeErr = (0, ast_utils_1.checkType)(ast, "absolute_reference");
        if (typeErr) {
          throw typeErr;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 2);
        if (lengthError) {
          throw lengthError;
        }
        const rowChild = ast.children[0];
        const colChild = ast.children[1];
        try {
          this.row = new row_1.AbsoluteRow(rowChild, table);
          this.column = new column_1.AbsoluteColumn(colChild, table);
        } catch (error) {
          throw error;
        }
      }
    };
    exports.CellDestination = CellDestination;
    var RangeDestination = class {
      constructor(ast, table, formatter) {
        this.merge = (source, table2) => this.range.asCells().andThen((cells) => mergeForCells(source, table2, cells, this.formatter));
        this.formatter = formatter;
        const typeErr = (0, ast_utils_1.checkType)(ast, "range");
        if (typeErr) {
          throw typeErr;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 2);
        if (lengthError) {
          throw lengthError;
        }
        ast.children.forEach((child) => {
          let childTypeErr = (0, ast_utils_1.checkType)(child, "source_reference");
          if (childTypeErr) {
            throw childTypeErr;
          }
          const childLengthError = (0, ast_utils_1.checkChildLength)(child, 1);
          if (childLengthError) {
            throw childLengthError;
          }
          childTypeErr = (0, ast_utils_1.checkType)(child.children[0], "absolute_reference");
          if (childTypeErr) {
            throw childTypeErr;
          }
        });
        this.range = new range_1.Range(ast, table);
      }
    };
    exports.RangeDestination = RangeDestination;
    var mergeForCells = (source, table, cells, formatter) => cells.reduce((currentTable, currentCell) => currentTable.andThen((t) => source.getValue(t, currentCell).andThen((val) => (0, neverthrow_1.ok)(val.toString())).andThen((val) => (0, neverthrow_1.ok)(val.trim() === "" ? "0" : val)).andThen((val) => (0, neverthrow_1.ok)(t.setCellAt(currentCell.row, currentCell.column, formatter.format(val))))), (0, neverthrow_1.ok)(table));
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/display_directive.js
var require_display_directive = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/display_directive.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DisplayDirective = exports.DefaultFormatter = void 0;
    var ast_utils_1 = require_ast_utils();
    var DefaultFormatter = class {
      constructor() {
        this.format = (num) => {
          if (typeof num === "string") {
            return num;
          }
          return num.toString();
        };
      }
    };
    exports.DefaultFormatter = DefaultFormatter;
    var DisplayDirective = class {
      constructor(ast) {
        this.format = (num) => {
          const parsed = typeof num === "string" ? parseFloat(num) : num;
          if (this.displayAsDatetime) {
            const date = new Date(parsed);
            const pad = (v) => `0${v}`.slice(-2);
            const y = date.getFullYear();
            const mo = pad(date.getMonth() + 1);
            const d = pad(date.getDate());
            const h = pad(date.getHours());
            const min = pad(date.getMinutes());
            return `${y}-${mo}-${d} ${h}:${min}`;
          }
          if (this.displayAsHourMinute) {
            let sign = parsed < 0 ? "-" : "";
            const minutes = Math.floor(Math.abs(parsed) / 6e4);
            const pad = (v) => `0${v}`.slice(-2);
            const h = pad(Math.floor(minutes / 60));
            const m = pad(minutes % 60);
            return `${sign}${h}:${m}`;
          }
          return parsed.toFixed(this.decimalLength);
        };
        let typeError = (0, ast_utils_1.checkType)(ast, "display_directive");
        if (typeError) {
          throw typeError;
        }
        let lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
        if (lengthError) {
          throw lengthError;
        }
        const displayDirectiveOption = ast.children[0];
        typeError = (0, ast_utils_1.checkType)(displayDirectiveOption, "display_directive_option");
        if (typeError) {
          throw typeError;
        }
        lengthError = (0, ast_utils_1.checkChildLength)(displayDirectiveOption, 1);
        if (lengthError) {
          throw lengthError;
        }
        const formattingDirective = displayDirectiveOption.children[0];
        typeError = (0, ast_utils_1.checkType)(formattingDirective, "formatting_directive", "datetime_directive", "hourminute_directive");
        if (typeError) {
          throw typeError;
        }
        this.displayAsDatetime = formattingDirective.type === "datetime_directive";
        this.displayAsHourMinute = formattingDirective.type === "hourminute_directive";
        if (this.displayAsDatetime || this.displayAsHourMinute) {
          this.decimalLength = -1;
          return;
        }
        lengthError = (0, ast_utils_1.checkChildLength)(formattingDirective, 1);
        if (lengthError) {
          throw lengthError;
        }
        const formattingDirectiveLength = formattingDirective.children[0];
        typeError = (0, ast_utils_1.checkType)(formattingDirectiveLength, "int");
        if (typeError) {
          throw typeError;
        }
        this.decimalLength = parseInt(formattingDirectiveLength.text);
      }
    };
    exports.DisplayDirective = DisplayDirective;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/single_param_function.js
var require_single_param_function = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/single_param_function.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SingleParamFunctionCall = void 0;
    var neverthrow_1 = require_neverthrow();
    var ast_utils_1 = require_ast_utils();
    var calc_1 = require_calc();
    var results_1 = require_results();
    var decimal_js_1 = __importDefault(require_decimal());
    var SingleParamFunctionCall = class {
      constructor(ast, table) {
        this.getValue = (table2, cell) => this.param.getValue(table2, cell).andThen((sourceData) => (
          // The operation functions do not throw errors because data arity has
          // already been validated.
          (0, neverthrow_1.ok)(this.op(sourceData))
        ));
        const typeError = (0, ast_utils_1.checkType)(ast, "single_param_function_call");
        if (typeError) {
          throw typeError;
        }
        const lengthError = (0, ast_utils_1.checkChildLength)(ast, 2);
        if (lengthError) {
          throw lengthError;
        }
        const childTypeError = (0, ast_utils_1.checkType)(ast.children[0], "single_param_function");
        if (childTypeError) {
          throw childTypeError;
        }
        const functionName = ast.children[0].text;
        switch (functionName) {
          case "sum":
            this.op = sum;
            break;
          case "mean":
            this.op = mean;
            break;
          default:
            throw Error("Unknown single param function call: " + functionName);
        }
        this.param = new calc_1.Source(ast.children[1], table);
      }
    };
    exports.SingleParamFunctionCall = SingleParamFunctionCall;
    var sum = (value) => {
      const total = value.val.reduce((runningTotal, currentRow) => currentRow.reduce((rowTotal, currentCell) => {
        const currentCellValue = (0, results_1.FloatOrMilliseconds)(currentCell);
        return currentCellValue.add(rowTotal);
      }, runningTotal), new decimal_js_1.default(0));
      return new results_1.Value([[total.toString()]]);
    };
    var mean = (value) => {
      const { total, count } = value.val.reduce(({ total: runningTotal1, count: currentCount1 }, currentRow) => currentRow.reduce(({ total: runningTotal2, count: currentCount2 }, currentCell) => ({
        total: runningTotal2 + +currentCell,
        count: currentCount2 + 1
      }), { total: runningTotal1, count: currentCount1 }), { total: 0, count: 0 });
      return new results_1.Value([[(total / count).toString()]]);
    };
  }
});

// node_modules/ebnf/dist/TokenError.js
var require_TokenError = __commonJS({
  "node_modules/ebnf/dist/TokenError.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TokenError = void 0;
    var TokenError = class extends Error {
      constructor(message, token) {
        super(message);
        this.message = message;
        this.token = token;
        if (token && token.errors)
          token.errors.push(this);
        else
          throw this;
      }
      inspect() {
        return "SyntaxError: " + this.message;
      }
    };
    exports.TokenError = TokenError;
  }
});

// node_modules/ebnf/dist/Parser.js
var require_Parser = __commonJS({
  "node_modules/ebnf/dist/Parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Parser = exports.findRuleByName = exports.parseRuleName = exports.escapeRegExp = exports.readToken = void 0;
    var UPPER_SNAKE_RE = /^[A-Z0-9_]+$/;
    var decorationRE = /(\?|\+|\*)$/;
    var preDecorationRE = /^(@|&|!)/;
    var WS_RULE = "WS";
    var TokenError_1 = require_TokenError();
    function readToken(txt, expr) {
      let result = expr.exec(txt);
      if (result && result.index == 0) {
        if (result[0].length == 0 && expr.source.length > 0)
          return null;
        return {
          type: null,
          text: result[0],
          rest: txt.substr(result[0].length),
          start: 0,
          end: result[0].length - 1,
          fullText: result[0],
          errors: [],
          children: [],
          parent: null
        };
      }
      return null;
    }
    exports.readToken = readToken;
    function escapeRegExp(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
    }
    exports.escapeRegExp = escapeRegExp;
    function fixRest(token) {
      token.rest = "";
      token.children && token.children.forEach((c) => fixRest(c));
    }
    function fixPositions(token, start) {
      token.start += start;
      token.end += start;
      token.children && token.children.forEach((c) => fixPositions(c, token.start));
    }
    function agregateErrors(errors, token) {
      if (token.errors && token.errors.length)
        token.errors.forEach((err) => errors.push(err));
      token.children && token.children.forEach((tok) => agregateErrors(errors, tok));
    }
    function parseRuleName(name) {
      let postDecoration = decorationRE.exec(name);
      let preDecoration = preDecorationRE.exec(name);
      let postDecorationText = postDecoration && postDecoration[0] || "";
      let preDecorationText = preDecoration && preDecoration[0] || "";
      let out = {
        raw: name,
        name: name.replace(decorationRE, "").replace(preDecorationRE, ""),
        isOptional: postDecorationText == "?" || postDecorationText == "*",
        allowRepetition: postDecorationText == "+" || postDecorationText == "*",
        atLeastOne: postDecorationText == "+",
        lookupPositive: preDecorationText == "&",
        lookupNegative: preDecorationText == "!",
        pinned: preDecorationText == "@",
        lookup: false,
        isLiteral: false
      };
      out.isLiteral = out.name[0] == "'" || out.name[0] == '"';
      out.lookup = out.lookupNegative || out.lookupPositive;
      return out;
    }
    exports.parseRuleName = parseRuleName;
    function findRuleByName(name, parser) {
      let parsed = parseRuleName(name);
      return parser.cachedRules[parsed.name] || null;
    }
    exports.findRuleByName = findRuleByName;
    function stripRules(token, re) {
      if (token.children) {
        let localRules = token.children.filter((x) => x.type && re.test(x.type));
        for (let i = 0; i < localRules.length; i++) {
          let indexOnChildren = token.children.indexOf(localRules[i]);
          if (indexOnChildren != -1) {
            token.children.splice(indexOnChildren, 1);
          }
        }
        token.children.forEach((c) => stripRules(c, re));
      }
    }
    var ignoreMissingRules = ["EOF"];
    var Parser = class {
      constructor(grammarRules, options) {
        this.grammarRules = grammarRules;
        this.options = options;
        this.cachedRules = {};
        this.debug = options ? options.debug === true : false;
        let errors = [];
        let neededRules = [];
        grammarRules.forEach((rule) => {
          let parsedName = parseRuleName(rule.name);
          if (parsedName.name in this.cachedRules) {
            errors.push("Duplicated rule " + parsedName.name);
            return;
          } else {
            this.cachedRules[parsedName.name] = rule;
          }
          if (!rule.bnf || !rule.bnf.length) {
            let error = "Missing rule content, rule: " + rule.name;
            if (errors.indexOf(error) == -1)
              errors.push(error);
          } else {
            rule.bnf.forEach((options2) => {
              if (typeof options2[0] === "string") {
                let parsed = parseRuleName(options2[0]);
                if (parsed.name == rule.name) {
                  let error = "Left recursion is not allowed, rule: " + rule.name;
                  if (errors.indexOf(error) == -1)
                    errors.push(error);
                }
              }
              options2.forEach((option) => {
                if (typeof option == "string") {
                  let name = parseRuleName(option);
                  if (!name.isLiteral && neededRules.indexOf(name.name) == -1 && ignoreMissingRules.indexOf(name.name) == -1)
                    neededRules.push(name.name);
                }
              });
            });
          }
          if (WS_RULE == rule.name)
            rule.implicitWs = false;
          if (rule.implicitWs) {
            if (neededRules.indexOf(WS_RULE) == -1)
              neededRules.push(WS_RULE);
          }
          if (rule.recover) {
            if (neededRules.indexOf(rule.recover) == -1)
              neededRules.push(rule.recover);
          }
        });
        neededRules.forEach((ruleName) => {
          if (!(ruleName in this.cachedRules)) {
            errors.push("Missing rule " + ruleName);
          }
        });
        if (errors.length)
          throw new Error(errors.join("\n"));
      }
      getAST(txt, target) {
        if (!target) {
          target = this.grammarRules.filter((x) => !x.fragment && x.name.indexOf("%") != 0)[0].name;
        }
        let result = this.parse(txt, target);
        if (result) {
          agregateErrors(result.errors, result);
          fixPositions(result, 0);
          stripRules(result, /^%/);
          if (!this.options || !this.options.keepUpperRules)
            stripRules(result, UPPER_SNAKE_RE);
          let rest = result.rest;
          if (rest) {
            new TokenError_1.TokenError("Unexpected end of input: \n" + rest, result);
          }
          fixRest(result);
          result.rest = rest;
        }
        return result;
      }
      emitSource() {
        return "CANNOT EMIT SOURCE FROM BASE Parser";
      }
      parse(txt, target, recursion = 0) {
        let out = null;
        let type = parseRuleName(target);
        let expr;
        let printable = this.debug && /*!isLiteral &*/
        !UPPER_SNAKE_RE.test(type.name);
        printable && console.log(new Array(recursion).join("\u2502  ") + "Trying to get " + target + " from " + JSON.stringify(txt.split("\n")[0]));
        let realType = type.name;
        let targetLex = findRuleByName(type.name, this);
        if (type.name == "EOF") {
          if (txt.length) {
            return null;
          } else if (txt.length == 0) {
            return {
              type: "EOF",
              text: "",
              rest: "",
              start: 0,
              end: 0,
              fullText: "",
              errors: [],
              children: [],
              parent: null
            };
          }
        }
        try {
          if (!targetLex && type.isLiteral) {
            let src = type.name.trim();
            if (src.startsWith('"')) {
              src = JSON.parse(src);
            } else if (src.startsWith("'")) {
              src = src.replace(/^'(.+)'$/, "$1").replace(/\\'/g, "'");
            }
            if (src === "") {
              return {
                type: "%%EMPTY%%",
                text: "",
                rest: txt,
                start: 0,
                end: 0,
                fullText: "",
                errors: [],
                children: [],
                parent: null
              };
            }
            expr = new RegExp(escapeRegExp(src));
            realType = null;
          }
        } catch (e) {
          if (e instanceof ReferenceError) {
            console.error(e);
          }
          return null;
        }
        if (expr) {
          let result = readToken(txt, expr);
          if (result) {
            result.type = realType;
            return result;
          }
        } else {
          let options = targetLex.bnf;
          if (options instanceof Array) {
            options.forEach((phases) => {
              if (out)
                return;
              let pinned = null;
              let tmp = {
                type: type.name,
                text: "",
                children: [],
                end: 0,
                errors: [],
                fullText: "",
                parent: null,
                start: 0,
                rest: txt
              };
              if (targetLex.fragment)
                tmp.fragment = true;
              let tmpTxt = txt;
              let position = 0;
              let allOptional = phases.length > 0;
              let foundSomething = false;
              for (let i = 0; i < phases.length; i++) {
                if (typeof phases[i] == "string") {
                  let localTarget = parseRuleName(phases[i]);
                  allOptional = allOptional && localTarget.isOptional;
                  let got;
                  let foundAtLeastOne = false;
                  do {
                    got = null;
                    if (targetLex.implicitWs) {
                      got = this.parse(tmpTxt, localTarget.name, recursion + 1);
                      if (!got) {
                        let WS;
                        do {
                          WS = this.parse(tmpTxt, WS_RULE, recursion + 1);
                          if (WS) {
                            tmp.text = tmp.text + WS.text;
                            tmp.end = tmp.text.length;
                            WS.parent = tmp;
                            tmp.children.push(WS);
                            tmpTxt = tmpTxt.substr(WS.text.length);
                            position += WS.text.length;
                          } else {
                            break;
                          }
                        } while (WS && WS.text.length);
                      }
                    }
                    got = got || this.parse(tmpTxt, localTarget.name, recursion + 1);
                    if (localTarget.lookupNegative) {
                      if (got)
                        return;
                      break;
                    }
                    if (localTarget.lookupPositive) {
                      if (!got)
                        return;
                    }
                    if (!got) {
                      if (localTarget.isOptional)
                        break;
                      if (localTarget.atLeastOne && foundAtLeastOne)
                        break;
                    }
                    if (got && targetLex.pinned == i + 1) {
                      pinned = got;
                      printable && console.log(new Array(recursion + 1).join("\u2502  ") + "\u2514\u2500 " + got.type + " PINNED");
                    }
                    if (!got)
                      got = this.parseRecovery(targetLex, tmpTxt, recursion + 1);
                    if (!got) {
                      if (pinned) {
                        out = tmp;
                        got = {
                          type: "SyntaxError",
                          text: tmpTxt,
                          children: [],
                          end: tmpTxt.length,
                          errors: [],
                          fullText: "",
                          parent: null,
                          start: 0,
                          rest: ""
                        };
                        if (tmpTxt.length) {
                          new TokenError_1.TokenError(`Unexpected end of input. Expecting ${localTarget.name} Got: ${tmpTxt}`, got);
                        } else {
                          new TokenError_1.TokenError(`Unexpected end of input. Missing ${localTarget.name}`, got);
                        }
                        printable && console.log(new Array(recursion + 1).join("\u2502  ") + "\u2514\u2500 " + got.type + " " + JSON.stringify(got.text));
                      } else {
                        return;
                      }
                    }
                    foundAtLeastOne = true;
                    foundSomething = true;
                    if (got.type == "%%EMPTY%%") {
                      break;
                    }
                    got.start += position;
                    got.end += position;
                    if (!localTarget.lookupPositive && got.type) {
                      if (got.fragment) {
                        got.children && got.children.forEach((x) => {
                          x.start += position;
                          x.end += position;
                          x.parent = tmp;
                          tmp.children.push(x);
                        });
                      } else {
                        got.parent = tmp;
                        tmp.children.push(got);
                      }
                    }
                    if (localTarget.lookup)
                      got.lookup = true;
                    printable && console.log(new Array(recursion + 1).join("\u2502  ") + "\u2514\u2500 " + got.type + " " + JSON.stringify(got.text));
                    if (!localTarget.lookup && !got.lookup) {
                      tmp.text = tmp.text + got.text;
                      tmp.end = tmp.text.length;
                      tmpTxt = tmpTxt.substr(got.text.length);
                      position += got.text.length;
                    }
                    tmp.rest = tmpTxt;
                  } while (got && localTarget.allowRepetition && tmpTxt.length && !got.lookup);
                } else {
                  let got = readToken(tmpTxt, phases[i]);
                  if (!got) {
                    return;
                  }
                  printable && console.log(new Array(recursion + 1).join("\u2502  ") + "\u2514> " + JSON.stringify(got.text) + phases[i].source);
                  foundSomething = true;
                  got.start += position;
                  got.end += position;
                  tmp.text = tmp.text + got.text;
                  tmp.end = tmp.text.length;
                  tmpTxt = tmpTxt.substr(got.text.length);
                  position += got.text.length;
                  tmp.rest = tmpTxt;
                }
              }
              if (foundSomething) {
                out = tmp;
                printable && console.log(new Array(recursion).join("\u2502  ") + "\u251C<\u2500\u2534< PUSHING " + out.type + " " + JSON.stringify(out.text));
              }
            });
          }
          if (out && targetLex.simplifyWhenOneChildren && out.children.length == 1) {
            out = out.children[0];
          }
        }
        if (!out) {
          printable && console.log(target + " NOT RESOLVED FROM " + txt);
        }
        return out;
      }
      parseRecovery(recoverableToken, tmpTxt, recursion) {
        if (recoverableToken.recover && tmpTxt.length) {
          let printable = this.debug;
          printable && console.log(new Array(recursion + 1).join("\u2502  ") + "Trying to recover until token " + recoverableToken.recover + " from " + JSON.stringify(tmpTxt.split("\n")[0] + tmpTxt.split("\n")[1]));
          let tmp = {
            type: "SyntaxError",
            text: "",
            children: [],
            end: 0,
            errors: [],
            fullText: "",
            parent: null,
            start: 0,
            rest: ""
          };
          let got;
          do {
            got = this.parse(tmpTxt, recoverableToken.recover, recursion + 1);
            if (got) {
              new TokenError_1.TokenError('Unexpected input: "' + tmp.text + `" Expecting: ${recoverableToken.name}`, tmp);
              break;
            } else {
              tmp.text = tmp.text + tmpTxt[0];
              tmp.end = tmp.text.length;
              tmpTxt = tmpTxt.substr(1);
            }
          } while (!got && tmpTxt.length > 0);
          if (tmp.text.length > 0 && got) {
            printable && console.log(new Array(recursion + 1).join("\u2502  ") + "Recovered text: " + JSON.stringify(tmp.text));
            return tmp;
          }
        }
        return null;
      }
    };
    exports.Parser = Parser;
    exports.default = Parser;
  }
});

// node_modules/ebnf/dist/SemanticHelpers.js
var require_SemanticHelpers = __commonJS({
  "node_modules/ebnf/dist/SemanticHelpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findChildrenByType = void 0;
    function findChildrenByType(token, type) {
      return token.children ? token.children.filter((x) => x.type == type) : [];
    }
    exports.findChildrenByType = findChildrenByType;
  }
});

// node_modules/ebnf/dist/Grammars/BNF.js
var require_BNF = __commonJS({
  "node_modules/ebnf/dist/Grammars/BNF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var SemanticHelpers_1 = require_SemanticHelpers();
    var Parser_1 = require_Parser();
    var BNF;
    (function(BNF2) {
      BNF2.RULES = [
        {
          name: "syntax",
          bnf: [["RULE_EOL*", "rule+"]]
        },
        {
          name: "rule",
          bnf: [
            [
              '" "*',
              '"<"',
              "rule-name",
              '">"',
              '" "*',
              '"::="',
              "firstExpression",
              "otherExpression*",
              '" "*',
              "RULE_EOL+",
              '" "*'
            ]
          ]
        },
        {
          name: "firstExpression",
          bnf: [['" "*', "list"]]
        },
        {
          name: "otherExpression",
          bnf: [['" "*', '"|"', '" "*', "list"]]
        },
        {
          name: "RULE_EOL",
          bnf: [['"\\r"'], ['"\\n"']]
        },
        {
          name: "list",
          bnf: [["term", '" "*', "list"], ["term"]]
        },
        {
          name: "term",
          bnf: [["literal"], ['"<"', "rule-name", '">"']]
        },
        {
          name: "literal",
          bnf: [[`'"'`, "RULE_CHARACTER1*", `'"'`], [`"'"`, "RULE_CHARACTER2*", `"'"`]]
        },
        {
          name: "RULE_CHARACTER",
          bnf: [['" "'], ["RULE_LETTER"], ["RULE_DIGIT"], ["RULE_SYMBOL"]]
        },
        {
          name: "RULE_LETTER",
          bnf: [
            ['"A"'],
            ['"B"'],
            ['"C"'],
            ['"D"'],
            ['"E"'],
            ['"F"'],
            ['"G"'],
            ['"H"'],
            ['"I"'],
            ['"J"'],
            ['"K"'],
            ['"L"'],
            ['"M"'],
            ['"N"'],
            ['"O"'],
            ['"P"'],
            ['"Q"'],
            ['"R"'],
            ['"S"'],
            ['"T"'],
            ['"U"'],
            ['"V"'],
            ['"W"'],
            ['"X"'],
            ['"Y"'],
            ['"Z"'],
            ['"a"'],
            ['"b"'],
            ['"c"'],
            ['"d"'],
            ['"e"'],
            ['"f"'],
            ['"g"'],
            ['"h"'],
            ['"i"'],
            ['"j"'],
            ['"k"'],
            ['"l"'],
            ['"m"'],
            ['"n"'],
            ['"o"'],
            ['"p"'],
            ['"q"'],
            ['"r"'],
            ['"s"'],
            ['"t"'],
            ['"u"'],
            ['"v"'],
            ['"w"'],
            ['"x"'],
            ['"y"'],
            ['"z"']
          ]
        },
        {
          name: "RULE_DIGIT",
          bnf: [['"0"'], ['"1"'], ['"2"'], ['"3"'], ['"4"'], ['"5"'], ['"6"'], ['"7"'], ['"8"'], ['"9"']]
        },
        {
          name: "RULE_SYMBOL",
          bnf: [
            ['"-"'],
            ['"_"'],
            ['"!"'],
            ['"#"'],
            ['"$"'],
            ['"%"'],
            ['"&"'],
            ['"("'],
            ['")"'],
            ['"*"'],
            ['"+"'],
            ['","'],
            ['"-"'],
            ['"."'],
            ['"/"'],
            ['":"'],
            ['";"'],
            ['"<"'],
            ['"="'],
            ['">"'],
            ['"?"'],
            ['"@"'],
            ['"["'],
            ['"\\"'],
            ['"]"'],
            ['"^"'],
            ['"_"'],
            ['"`"'],
            ['"{"'],
            ['"|"'],
            ['"}"'],
            ['"~"']
          ]
        },
        {
          name: "RULE_CHARACTER1",
          bnf: [["RULE_CHARACTER"], [`"'"`]]
        },
        {
          name: "RULE_CHARACTER2",
          bnf: [["RULE_CHARACTER"], [`'"'`]]
        },
        {
          name: "rule-name",
          bnf: [["RULE_LETTER", "RULE_CHAR*"]]
        },
        {
          name: "RULE_CHAR",
          bnf: [["RULE_LETTER"], ["RULE_DIGIT"], ['"_"'], ['"-"']]
        }
      ];
      BNF2.defaultParser = new Parser_1.Parser(BNF2.RULES, { debug: false });
      function getAllTerms(expr) {
        let terms = SemanticHelpers_1.findChildrenByType(expr, "term").map((term) => {
          return SemanticHelpers_1.findChildrenByType(term, "literal").concat(SemanticHelpers_1.findChildrenByType(term, "rule-name"))[0].text;
        });
        SemanticHelpers_1.findChildrenByType(expr, "list").forEach((expr2) => {
          terms = terms.concat(getAllTerms(expr2));
        });
        return terms;
      }
      function getRules(source, parser = BNF2.defaultParser) {
        let ast = parser.getAST(source);
        if (!ast)
          throw new Error("Could not parse " + source);
        if (ast.errors && ast.errors.length) {
          throw ast.errors[0];
        }
        let rules = SemanticHelpers_1.findChildrenByType(ast, "rule");
        let ret = rules.map((rule) => {
          let name = SemanticHelpers_1.findChildrenByType(rule, "rule-name")[0].text;
          let expressions = SemanticHelpers_1.findChildrenByType(rule, "firstExpression").concat(SemanticHelpers_1.findChildrenByType(rule, "otherExpression"));
          let bnf = [];
          expressions.forEach((expr) => {
            bnf.push(getAllTerms(expr));
          });
          return {
            name,
            bnf
          };
        });
        if (!ret.some((x) => x.name == "EOL")) {
          ret.push({
            name: "EOL",
            bnf: [['"\\r\\n"', '"\\r"', '"\\n"']]
          });
        }
        return ret;
      }
      BNF2.getRules = getRules;
      function Transform(source, subParser = BNF2.defaultParser) {
        return getRules(source.join(""), subParser);
      }
      BNF2.Transform = Transform;
      class Parser extends Parser_1.Parser {
        constructor(source, options) {
          const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF2.RULES, { debug: true }) : BNF2.defaultParser;
          super(getRules(source, subParser), options);
          this.source = source;
        }
        emitSource() {
          return this.source;
        }
      }
      BNF2.Parser = Parser;
    })(BNF || (BNF = {}));
    exports.default = BNF;
  }
});

// node_modules/ebnf/dist/Grammars/W3CEBNF.js
var require_W3CEBNF = __commonJS({
  "node_modules/ebnf/dist/Grammars/W3CEBNF.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Parser_1 = require_Parser();
    var BNF;
    (function(BNF2) {
      BNF2.RULES = [
        {
          name: "Grammar",
          bnf: [["RULE_S*", "%Atomic*", "EOF"]]
        },
        {
          name: "%Atomic",
          bnf: [["Production", "RULE_S*"]],
          fragment: true
        },
        {
          name: "Production",
          bnf: [["NCName", "RULE_S*", '"::="', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", "RULE_EOL+", "RULE_S*"]]
        },
        {
          name: "NCName",
          bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
        },
        {
          name: "Choice",
          bnf: [["SequenceOrDifference", "%_Choice_1*"]],
          fragment: true
        },
        {
          name: "%_Choice_1",
          bnf: [["RULE_WHITESPACE*", '"|"', "RULE_WHITESPACE*", "SequenceOrDifference"]],
          fragment: true
        },
        {
          name: "SequenceOrDifference",
          bnf: [["Item", "RULE_WHITESPACE*", "%_Item_1?"]]
        },
        {
          name: "%_Item_1",
          bnf: [["Minus", "Item"], ["Item*"]],
          fragment: true
        },
        {
          name: "Minus",
          bnf: [['"-"']]
        },
        {
          name: "Item",
          bnf: [["RULE_WHITESPACE*", "%Primary", "PrimaryDecoration?"]],
          fragment: true
        },
        {
          name: "PrimaryDecoration",
          bnf: [['"?"'], ['"*"'], ['"+"']]
        },
        {
          name: "DecorationName",
          bnf: [['"ebnf://"', /[^\x5D#]+/]]
        },
        {
          name: "%Primary",
          bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
          fragment: true
        },
        {
          name: "SubItem",
          bnf: [['"("', "RULE_WHITESPACE*", "Choice", "RULE_WHITESPACE*", '")"']]
        },
        {
          name: "StringLiteral",
          bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]],
          pinned: 1
        },
        {
          name: "CharCode",
          bnf: [['"#x"', /[0-9a-zA-Z]+/]]
        },
        {
          name: "CharClass",
          bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
        },
        {
          name: "%RULE_CharClass_1",
          bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
          fragment: true
        },
        {
          name: "RULE_Char",
          bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
        },
        {
          name: "CharRange",
          bnf: [["RULE_Char", '"-"', "RULE_Char"]]
        },
        {
          name: "CharCodeRange",
          bnf: [["CharCode", '"-"', "CharCode"]]
        },
        {
          name: "RULE_WHITESPACE",
          bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
        },
        {
          name: "RULE_S",
          bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
        },
        {
          name: "%RULE_WHITESPACE_CHAR",
          bnf: [[/\x09/], [/\x20/]],
          fragment: true
        },
        {
          name: "Comment",
          bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
        },
        {
          name: "%RULE_Comment_Body",
          bnf: [['!"*/"', /[^*]/]],
          fragment: true
        },
        {
          name: "RULE_EOL",
          bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
        },
        {
          name: "Link",
          bnf: [["'['", "Url", "']'"]]
        },
        {
          name: "Url",
          bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
        },
        {
          name: "%Url1",
          bnf: [['"#"', "NCName"]],
          fragment: true
        }
      ];
      BNF2.defaultParser = new Parser_1.Parser(BNF2.RULES, { debug: false });
      const preDecorationRE = /^(!|&)/;
      const decorationRE = /(\?|\+|\*)$/;
      const subExpressionRE = /^%/;
      function getBNFRule(name, parser) {
        if (typeof name == "string") {
          if (preDecorationRE.test(name))
            return "";
          let subexpression = subExpressionRE.test(name);
          if (subexpression) {
            let decoration = decorationRE.exec(name);
            let decorationText = decoration ? decoration[0] + " " : "";
            let lonely = isLonelyRule(name, parser);
            if (lonely)
              return getBNFBody(name, parser) + decorationText;
            return "(" + getBNFBody(name, parser) + ")" + decorationText;
          }
          return name;
        } else {
          return name.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
        }
      }
      function isLonelyRule(name, parser) {
        let rule = Parser_1.findRuleByName(name, parser);
        return rule && rule.bnf.length == 1 && rule.bnf[0].length == 1 && (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '"' || rule.bnf[0][0][0] == "'");
      }
      function getBNFChoice(rules, parser) {
        return rules.map((x) => getBNFRule(x, parser)).join(" ");
      }
      function getBNFBody(name, parser) {
        let rule = Parser_1.findRuleByName(name, parser);
        if (rule)
          return rule.bnf.map((x) => getBNFChoice(x, parser)).join(" | ");
        return "RULE_NOT_FOUND {" + name + "}";
      }
      function emit(parser) {
        let acumulator = [];
        parser.grammarRules.forEach((l) => {
          if (!/^%/.test(l.name)) {
            let recover = l.recover ? " /* { recoverUntil=" + l.recover + " } */" : "";
            acumulator.push(l.name + " ::= " + getBNFBody(l.name, parser) + recover);
          }
        });
        return acumulator.join("\n");
      }
      BNF2.emit = emit;
      let subitems = 0;
      function restar(total, resta) {
        console.log("reberia restar " + resta + " a " + total);
        throw new Error("Difference not supported yet");
      }
      function convertRegex(txt) {
        return new RegExp(txt.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
      }
      function getSubItems(tmpRules, seq, parentName) {
        let anterior = null;
        let bnfSeq = [];
        seq.children.forEach((x, i) => {
          if (x.type == "Minus") {
            restar(anterior, x);
          } else {
          }
          let decoration = seq.children[i + 1];
          decoration = decoration && decoration.type == "PrimaryDecoration" && decoration.text || "";
          let preDecoration = "";
          switch (x.type) {
            case "SubItem":
              let name = "%" + (parentName + subitems++);
              createRule(tmpRules, x, name);
              bnfSeq.push(preDecoration + name + decoration);
              break;
            case "NCName":
            case "StringLiteral":
              bnfSeq.push(preDecoration + x.text + decoration);
              break;
            case "CharCode":
            case "CharClass":
              if (decoration || preDecoration) {
                let newRule = {
                  name: "%" + (parentName + subitems++),
                  bnf: [[convertRegex(x.text)]]
                };
                tmpRules.push(newRule);
                bnfSeq.push(preDecoration + newRule.name + decoration);
              } else {
                bnfSeq.push(convertRegex(x.text));
              }
              break;
            case "PrimaryDecoration":
              break;
            default:
              throw new Error(" HOW SHOULD I PARSE THIS? " + x.type + " -> " + JSON.stringify(x.text));
          }
          anterior = x;
        });
        return bnfSeq;
      }
      function createRule(tmpRules, token, name) {
        let bnf = token.children.filter((x) => x.type == "SequenceOrDifference").map((s) => getSubItems(tmpRules, s, name));
        let rule = {
          name,
          bnf
        };
        let recover = null;
        bnf.forEach((x) => {
          recover = recover || x["recover"];
          delete x["recover"];
        });
        if (name.indexOf("%") == 0)
          rule.fragment = true;
        if (recover)
          rule.recover = recover;
        tmpRules.push(rule);
      }
      function getRules(source, parser = BNF2.defaultParser) {
        let ast = parser.getAST(source);
        if (!ast)
          throw new Error("Could not parse " + source);
        if (ast.errors && ast.errors.length) {
          throw ast.errors[0];
        }
        let tmpRules = [];
        ast.children.filter((x) => x.type == "Production").map((x) => {
          let name = x.children.filter((x2) => x2.type == "NCName")[0].text;
          createRule(tmpRules, x, name);
        });
        return tmpRules;
      }
      BNF2.getRules = getRules;
      function Transform(source, subParser = BNF2.defaultParser) {
        return getRules(source.join(""), subParser);
      }
      BNF2.Transform = Transform;
      class Parser extends Parser_1.Parser {
        constructor(source, options) {
          const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF2.RULES, { debug: true }) : BNF2.defaultParser;
          super(getRules(source, subParser), options);
        }
        emitSource() {
          return emit(this);
        }
      }
      BNF2.Parser = Parser;
    })(BNF || (BNF = {}));
    exports.default = BNF;
  }
});

// node_modules/ebnf/dist/Grammars/Custom.js
var require_Custom = __commonJS({
  "node_modules/ebnf/dist/Grammars/Custom.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var TokenError_1 = require_TokenError();
    var Parser_1 = require_Parser();
    var BNF;
    (function(BNF2) {
      BNF2.RULES = [
        {
          name: "Grammar",
          bnf: [["RULE_S*", "Attributes?", "RULE_S*", "%Atomic*", "EOF"]]
        },
        {
          name: "%Atomic",
          bnf: [["Production", "RULE_S*"]],
          fragment: true
        },
        {
          name: "Production",
          bnf: [
            [
              "NCName",
              "RULE_S*",
              '"::="',
              "RULE_WHITESPACE*",
              "%Choice",
              "RULE_WHITESPACE*",
              "Attributes?",
              "RULE_EOL+",
              "RULE_S*"
            ]
          ]
        },
        {
          name: "NCName",
          bnf: [[/[a-zA-Z][a-zA-Z_0-9]*/]]
        },
        {
          name: "Attributes",
          bnf: [['"{"', "Attribute", "%Attributes*", "RULE_S*", '"}"']]
        },
        {
          name: "%Attributes",
          bnf: [["RULE_S*", '","', "Attribute"]],
          fragment: true
        },
        {
          name: "Attribute",
          bnf: [["RULE_S*", "NCName", "RULE_WHITESPACE*", '"="', "RULE_WHITESPACE*", "AttributeValue"]]
        },
        {
          name: "AttributeValue",
          bnf: [["NCName"], [/[1-9][0-9]*/]]
        },
        {
          name: "%Choice",
          bnf: [["SequenceOrDifference", "%_Choice_1*"]],
          fragment: true
        },
        {
          name: "%_Choice_1",
          bnf: [["RULE_S*", '"|"', "RULE_S*", "SequenceOrDifference"]],
          fragment: true
        },
        {
          name: "SequenceOrDifference",
          bnf: [["%Item", "RULE_WHITESPACE*", "%_Item_1?"]]
        },
        {
          name: "%_Item_1",
          bnf: [["Minus", "%Item"], ["%Item*"]],
          fragment: true
        },
        {
          name: "Minus",
          bnf: [['"-"']]
        },
        {
          name: "%Item",
          bnf: [["RULE_WHITESPACE*", "PrimaryPreDecoration?", "%Primary", "PrimaryDecoration?"]],
          fragment: true
        },
        {
          name: "PrimaryDecoration",
          bnf: [['"?"'], ['"*"'], ['"+"']]
        },
        {
          name: "PrimaryPreDecoration",
          bnf: [['"&"'], ['"!"'], ['"~"']]
        },
        {
          name: "%Primary",
          bnf: [["NCName"], ["StringLiteral"], ["CharCode"], ["CharClass"], ["SubItem"]],
          fragment: true
        },
        {
          name: "SubItem",
          bnf: [['"("', "RULE_S*", "%Choice", "RULE_S*", '")"']]
        },
        {
          name: "StringLiteral",
          bnf: [[`'"'`, /[^"]*/, `'"'`], [`"'"`, /[^']*/, `"'"`]]
        },
        {
          name: "CharCode",
          bnf: [['"#x"', /[0-9a-zA-Z]+/]]
        },
        {
          name: "CharClass",
          bnf: [["'['", "'^'?", "%RULE_CharClass_1+", '"]"']]
        },
        {
          name: "%RULE_CharClass_1",
          bnf: [["CharCodeRange"], ["CharRange"], ["CharCode"], ["RULE_Char"]],
          fragment: true
        },
        {
          name: "RULE_Char",
          bnf: [[/\x09/], [/\x0A/], [/\x0D/], [/[\x20-\x5c]/], [/[\x5e-\uD7FF]/], [/[\uE000-\uFFFD]/]]
        },
        {
          name: "CharRange",
          bnf: [["RULE_Char", '"-"', "RULE_Char"]]
        },
        {
          name: "CharCodeRange",
          bnf: [["CharCode", '"-"', "CharCode"]]
        },
        {
          name: "RULE_WHITESPACE",
          bnf: [["%RULE_WHITESPACE_CHAR*"], ["Comment", "RULE_WHITESPACE*"]]
        },
        {
          name: "RULE_S",
          bnf: [["RULE_WHITESPACE", "RULE_S*"], ["RULE_EOL", "RULE_S*"]]
        },
        {
          name: "%RULE_WHITESPACE_CHAR",
          bnf: [[/\x09/], [/\x20/]],
          fragment: true
        },
        {
          name: "Comment",
          bnf: [['"/*"', "%RULE_Comment_Body*", '"*/"']]
        },
        {
          name: "%RULE_Comment_Body",
          bnf: [[/[^*]/], ['"*"+', /[^/]*/]],
          fragment: true
        },
        {
          name: "RULE_EOL",
          bnf: [[/\x0D/, /\x0A/], [/\x0A/], [/\x0D/]]
        },
        {
          name: "Link",
          bnf: [["'['", "Url", "']'"]]
        },
        {
          name: "Url",
          bnf: [[/[^\x5D:/?#]/, '"://"', /[^\x5D#]+/, "%Url1?"]]
        },
        {
          name: "%Url1",
          bnf: [['"#"', "NCName"]],
          fragment: true
        }
      ];
      BNF2.defaultParser = new Parser_1.Parser(BNF2.RULES, { debug: false });
      const preDecorationRE = /^(!|&)/;
      const decorationRE = /(\?|\+|\*)$/;
      const subExpressionRE = /^%/;
      function getBNFRule(name, parser) {
        if (typeof name == "string") {
          let decoration = decorationRE.exec(name);
          let preDecoration = preDecorationRE.exec(name);
          let preDecorationText = preDecoration ? preDecoration[0] : "";
          let decorationText = decoration ? decoration[0] + " " : "";
          let subexpression = subExpressionRE.test(name);
          if (subexpression) {
            let lonely = isLonelyRule(name, parser);
            if (lonely)
              return preDecorationText + getBNFBody(name, parser) + decorationText;
            return preDecorationText + "(" + getBNFBody(name, parser) + ")" + decorationText;
          }
          return name.replace(preDecorationRE, preDecorationText);
        } else {
          return name.source.replace(/\\(?:x|u)([a-zA-Z0-9]+)/g, "#x$1").replace(/\[\\(?:x|u)([a-zA-Z0-9]+)-\\(?:x|u)([a-zA-Z0-9]+)\]/g, "[#x$1-#x$2]");
        }
      }
      function isLonelyRule(name, parser) {
        let rule = Parser_1.findRuleByName(name, parser);
        return rule && rule.bnf.length == 1 && rule.bnf[0].length == 1 && (rule.bnf[0][0] instanceof RegExp || rule.bnf[0][0][0] == '"' || rule.bnf[0][0][0] == "'");
      }
      function getBNFChoice(rules, parser) {
        return rules.map((x) => getBNFRule(x, parser)).join(" ");
      }
      function getBNFBody(name, parser) {
        let rule = Parser_1.findRuleByName(name, parser);
        if (rule)
          return rule.bnf.map((x) => getBNFChoice(x, parser)).join(" | ");
        return "RULE_NOT_FOUND {" + name + "}";
      }
      function emit(parser) {
        let acumulator = [];
        parser.grammarRules.forEach((l) => {
          if (!/^%/.test(l.name)) {
            let recover = l.recover ? " { recoverUntil=" + l.recover + " }" : "";
            acumulator.push(l.name + " ::= " + getBNFBody(l.name, parser) + recover);
          }
        });
        return acumulator.join("\n");
      }
      BNF2.emit = emit;
      let subitems = 0;
      function restar(total, resta) {
        console.log("reberia restar " + resta + " a " + total);
        throw new Error("Difference not supported yet");
      }
      function convertRegex(txt) {
        return new RegExp(txt.replace(/#x([a-zA-Z0-9]{4})/g, "\\u$1").replace(/#x([a-zA-Z0-9]{3})/g, "\\u0$1").replace(/#x([a-zA-Z0-9]{2})/g, "\\x$1").replace(/#x([a-zA-Z0-9]{1})/g, "\\x0$1"));
      }
      function getSubItems(tmpRules, seq, parentName, parentAttributes) {
        let anterior = null;
        let bnfSeq = [];
        seq.children.forEach((x, i) => {
          if (x.type == "Minus") {
            restar(anterior, x);
          } else {
          }
          let decoration = seq.children[i + 1];
          decoration = decoration && decoration.type == "PrimaryDecoration" && decoration.text || "";
          let preDecoration = "";
          if (anterior && anterior.type == "PrimaryPreDecoration") {
            preDecoration = anterior.text;
          }
          let pinned = preDecoration == "~" ? 1 : void 0;
          if (pinned) {
            preDecoration = "";
          }
          switch (x.type) {
            case "SubItem":
              let name = "%" + (parentName + subitems++);
              createRule(tmpRules, x, name, parentAttributes);
              bnfSeq.push(preDecoration + name + decoration);
              break;
            case "NCName":
              bnfSeq.push(preDecoration + x.text + decoration);
              break;
            case "StringLiteral":
              if (decoration || preDecoration || !/^['"/()a-zA-Z0-9&_.:=,+*\-\^\\]+$/.test(x.text)) {
                bnfSeq.push(preDecoration + x.text + decoration);
              } else {
                for (const c of x.text.slice(1, -1)) {
                  if (parentAttributes && parentAttributes["ignoreCase"] == "true" && /[a-zA-Z]/.test(c)) {
                    bnfSeq.push(new RegExp("[" + c.toUpperCase() + c.toLowerCase() + "]"));
                  } else {
                    bnfSeq.push(new RegExp(Parser_1.escapeRegExp(c)));
                  }
                }
              }
              break;
            case "CharCode":
            case "CharClass":
              if (decoration || preDecoration) {
                let newRule = {
                  name: "%" + (parentName + subitems++),
                  bnf: [[convertRegex(x.text)]],
                  pinned
                };
                tmpRules.push(newRule);
                bnfSeq.push(preDecoration + newRule.name + decoration);
              } else {
                bnfSeq.push(convertRegex(x.text));
              }
              break;
            case "PrimaryPreDecoration":
            case "PrimaryDecoration":
              break;
            default:
              throw new Error(" HOW SHOULD I PARSE THIS? " + x.type + " -> " + JSON.stringify(x.text));
          }
          anterior = x;
        });
        return bnfSeq;
      }
      function createRule(tmpRules, token, name, parentAttributes = void 0) {
        let attrNode = token.children.filter((x) => x.type == "Attributes")[0];
        let attributes = {};
        if (attrNode) {
          attrNode.children.forEach((x) => {
            let name2 = x.children.filter((x2) => x2.type == "NCName")[0].text;
            if (name2 in attributes) {
              throw new TokenError_1.TokenError("Duplicated attribute " + name2, x);
            } else {
              attributes[name2] = x.children.filter((x2) => x2.type == "AttributeValue")[0].text;
            }
          });
        }
        let bnf = token.children.filter((x) => x.type == "SequenceOrDifference").map((s) => getSubItems(tmpRules, s, name, parentAttributes ? parentAttributes : attributes));
        let rule = {
          name,
          bnf
        };
        if (name.indexOf("%") == 0)
          rule.fragment = true;
        if (attributes["recoverUntil"]) {
          rule.recover = attributes["recoverUntil"];
          if (rule.bnf.length > 1)
            throw new TokenError_1.TokenError("only one-option productions are suitable for error recovering", token);
        }
        if ("pin" in attributes) {
          let num = parseInt(attributes["pin"]);
          if (!isNaN(num)) {
            rule.pinned = num;
          }
          if (rule.bnf.length > 1)
            throw new TokenError_1.TokenError("only one-option productions are suitable for pinning", token);
        }
        if ("ws" in attributes) {
          rule.implicitWs = attributes["ws"] != "explicit";
        } else {
          rule.implicitWs = null;
        }
        rule.fragment = rule.fragment || attributes["fragment"] == "true";
        rule.simplifyWhenOneChildren = attributes["simplifyWhenOneChildren"] == "true";
        tmpRules.push(rule);
      }
      function getRules(source, parser = BNF2.defaultParser) {
        let ast = parser.getAST(source);
        if (!ast)
          throw new Error("Could not parse " + source);
        if (ast.errors && ast.errors.length) {
          throw ast.errors[0];
        }
        let implicitWs = null;
        let attrNode = ast.children.filter((x) => x.type == "Attributes")[0];
        let attributes = {};
        if (attrNode) {
          attrNode.children.forEach((x) => {
            let name = x.children.filter((x2) => x2.type == "NCName")[0].text;
            if (name in attributes) {
              throw new TokenError_1.TokenError("Duplicated attribute " + name, x);
            } else {
              attributes[name] = x.children.filter((x2) => x2.type == "AttributeValue")[0].text;
            }
          });
        }
        implicitWs = attributes["ws"] == "implicit";
        let tmpRules = [];
        ast.children.filter((x) => x.type == "Production").map((x) => {
          let name = x.children.filter((x2) => x2.type == "NCName")[0].text;
          createRule(tmpRules, x, name);
        });
        tmpRules.forEach((rule) => {
          if (rule.implicitWs === null)
            rule.implicitWs = implicitWs;
        });
        return tmpRules;
      }
      BNF2.getRules = getRules;
      function Transform(source, subParser = BNF2.defaultParser) {
        return getRules(source.join(""), subParser);
      }
      BNF2.Transform = Transform;
      class Parser extends Parser_1.Parser {
        constructor(source, options) {
          const subParser = options && options.debugRulesParser === true ? new Parser_1.Parser(BNF2.RULES, { debug: true }) : BNF2.defaultParser;
          super(getRules(source, subParser), options);
        }
        emitSource() {
          return emit(this);
        }
      }
      BNF2.Parser = Parser;
    })(BNF || (BNF = {}));
    exports.default = BNF;
  }
});

// node_modules/ebnf/dist/Grammars/index.js
var require_Grammars = __commonJS({
  "node_modules/ebnf/dist/Grammars/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var BNF_1 = require_BNF();
    Object.defineProperty(exports, "BNF", { enumerable: true, get: function() {
      return BNF_1.default;
    } });
    var W3CEBNF_1 = require_W3CEBNF();
    Object.defineProperty(exports, "W3C", { enumerable: true, get: function() {
      return W3CEBNF_1.default;
    } });
    var Custom_1 = require_Custom();
    Object.defineProperty(exports, "Custom", { enumerable: true, get: function() {
      return Custom_1.default;
    } });
  }
});

// node_modules/ebnf/dist/index.js
var require_dist = __commonJS({
  "node_modules/ebnf/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Parser_1 = require_Parser();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var TokenError_1 = require_TokenError();
    Object.defineProperty(exports, "TokenError", { enumerable: true, get: function() {
      return TokenError_1.TokenError;
    } });
    exports.Grammars = require_Grammars();
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/calc/calc.js
var require_calc = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/calc/calc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseFormula = exports.parseAndApply = exports.Source = exports.Formula = void 0;
    var neverthrow_1 = require_neverthrow();
    var algebraic_operation_1 = require_algebraic_operation();
    var ast_utils_1 = require_ast_utils();
    var conditional_function_1 = require_conditional_function();
    var constant_1 = require_constant();
    var destination_1 = require_destination();
    var display_directive_1 = require_display_directive();
    var range_1 = require_range2();
    var reference_1 = require_reference();
    var single_param_function_1 = require_single_param_function();
    var ebnf_1 = require_dist();
    var lodash_1 = require_lodash();
    var parserGrammar = `
tblfm_line   ::= "<!-- TBLFM: " formula_list " -->"
formula_list ::= formula ( "::" formula_list )?
formula      ::= destination "=" source display_directive?

source           ::= range | source_reference | single_param_function_call | conditional_function_call | algebraic_operation | float | real
range            ::= source_reference ".." source_reference
source_reference ::= absolute_reference | relative_reference
destination      ::= range | absolute_reference

relative_reference ::= (relative_row | absolute_row) (relative_column | absolute_column) | relative_row | relative_column
relative_row ::= "@" ( "-" | "+" ) int
relative_column ::= "$" ( "-" | "+" ) int

absolute_reference ::= absolute_row absolute_column | absolute_row | absolute_column
absolute_row ::= "@" ( "I" | "<" | ">" | int )
absolute_column ::= "$" ( "<" | ">" | int )

single_param_function_call ::= single_param_function "(" source ")" 
single_param_function      ::= "mean" | "sum"

conditional_function_call ::= "if(" predicate "," " "? source "," " "? source ")"
predicate                 ::= source_without_range conditional_operator source_without_range
source_without_range      ::= source_reference | single_param_function_call | conditional_function_call | algebraic_operation | float | real
conditional_operator      ::= ">" | "<" | ">=" | "<=" | "==" | "!="

algebraic_operation ::= "(" source " "? algebraic_operator " "? source ")"
algebraic_operator  ::= "+" | "-" | "*" | "/"

display_directive        ::= ";" display_directive_option
display_directive_option ::= formatting_directive | datetime_directive | hourminute_directive
formatting_directive     ::= "%." int "f"
datetime_directive       ::= "dt"
hourminute_directive     ::= "hm"

float ::= "-"? int "." int
real ::= "-"? int
int  ::= [0-9]+
`;
    var Formula = class {
      constructor(ast, table) {
        this.merge = (table2) => this.destination.merge(this.source, table2);
        let formatter = new display_directive_1.DefaultFormatter();
        if (ast.children.length === 3) {
          formatter = new display_directive_1.DisplayDirective(ast.children[2]);
        }
        const destination = (0, destination_1.newDestination)(ast.children[0], table, formatter);
        if (destination.isErr()) {
          throw destination.error;
        }
        this.destination = destination.value;
        this.source = new Source(ast.children[1], table);
      }
    };
    exports.Formula = Formula;
    var Source = class {
      constructor(ast, table) {
        this.getValue = (table2, currentCell) => this.locationDescriptor.getValue(table2, currentCell);
        if (ast.type !== "source" && ast.type !== "source_without_range") {
          throw Error("Invalid AST token type of " + ast.type);
        }
        if (ast.children.length !== 1) {
          throw Error("Unexpected children length in Source");
        }
        const paramChild = ast.children[0];
        const vp = newValueProvider(paramChild, table);
        if (vp.isErr()) {
          throw vp.error;
        }
        this.locationDescriptor = vp.value;
      }
    };
    exports.Source = Source;
    var newValueProvider = (ast, table) => {
      try {
        switch (ast.type) {
          case "range":
            return (0, neverthrow_1.ok)(new range_1.Range(ast, table));
          case "source_reference":
            const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
            if (lengthError) {
              return (0, neverthrow_1.err)(lengthError);
            }
            return (0, neverthrow_1.ok)(new reference_1.Reference(ast.children[0], table));
          case "single_param_function_call":
            return (0, neverthrow_1.ok)(new single_param_function_1.SingleParamFunctionCall(ast, table));
          case "conditional_function_call":
            return (0, neverthrow_1.ok)(new conditional_function_1.ConditionalFunctionCall(ast, table));
          case "algebraic_operation":
            return (0, neverthrow_1.ok)(new algebraic_operation_1.AlgebraicOperation(ast, table));
          case "real":
            return (0, neverthrow_1.ok)(new constant_1.Constant(ast, table));
          case "float":
            return (0, neverthrow_1.ok)(new constant_1.Constant(ast, table));
          default:
            throw Error("Unrecognized valueProvider type " + ast.type);
        }
      } catch (error) {
        return (0, neverthrow_1.err)(error);
      }
    };
    var parseAndApply = (formulaLines, table) => {
      const formulas = formulaLines.reduce((prev, formulaLine) => prev.andThen((currentFormulas) => {
        const newFormulas = (0, exports.parseFormula)(formulaLine, table);
        if (newFormulas.isErr()) {
          return newFormulas;
        }
        return (0, neverthrow_1.ok)((0, lodash_1.concat)(newFormulas.value, currentFormulas));
      }), (0, neverthrow_1.ok)([]));
      return formulas.andThen((innerFormulas) => (
        // for each formula
        innerFormulas.reduceRight(
          (prevValue, formula) => (
            // If the previous formula didn't give an error
            prevValue.andThen((prevTable) => (
              // attempt to apply this formula to the table and return the result
              formula.merge(prevTable)
            ))
          ),
          // Start with the current table state
          (0, neverthrow_1.ok)(table)
        )
      ));
    };
    exports.parseAndApply = parseAndApply;
    var parseFormula = (line, table) => {
      const parser = new ebnf_1.Grammars.W3C.Parser(parserGrammar);
      const ast = parser.getAST(line);
      if (!ast) {
        return (0, neverthrow_1.err)(new Error(`Formula '${line}' could not be parsed`));
      }
      const typeError = (0, ast_utils_1.checkType)(ast, "tblfm_line");
      if (typeError) {
        return (0, neverthrow_1.err)(typeError);
      }
      const lengthError = (0, ast_utils_1.checkChildLength)(ast, 1);
      if (lengthError) {
        return (0, neverthrow_1.err)(lengthError);
      }
      let unparsedFormulas = ast.children[0].children;
      const formulas = [];
      try {
        do {
          formulas.push(new Formula(unparsedFormulas[0], table));
          if (unparsedFormulas.length > 1 && unparsedFormulas[1].type === "formula_list") {
            unparsedFormulas = unparsedFormulas[1].children;
          } else {
            unparsedFormulas = [];
          }
        } while (unparsedFormulas.length > 0);
        return (0, neverthrow_1.ok)(formulas);
      } catch (error) {
        return (0, neverthrow_1.err)(error);
      }
    };
    exports.parseFormula = parseFormula;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/table.js
var require_table = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/table.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Table = void 0;
    var calc_1 = require_calc();
    var focus_1 = require_focus();
    var point_1 = require_point();
    var range_1 = require_range();
    var Table = class _Table {
      /**
       * Creates a new `Table` object.
       *
       * @param rows - An array of rows that the table contains.
       * @param formulas - An array of formulas attached to the table.
       */
      constructor(rows) {
        this._rows = rows.slice();
      }
      /**
       * Gets the number of rows in the table.
       *
       * @returns The number of rows.
       */
      getHeight() {
        return this._rows.length;
      }
      /**
       * Gets the maximum width of the rows in the table.
       *
       * @returns The maximum width of the rows.
       */
      getWidth() {
        return this._rows.map((row) => row.getWidth()).reduce((x, y) => Math.max(x, y), 0);
      }
      /**
       * Gets the width of the header row.
       * Assumes that it is called on a valid table with a header row.
       *
       * @returns The width of the header row
       */
      getHeaderWidth() {
        return this._rows[0].getWidth();
      }
      /**
       * Gets the rows that the table contains.
       *
       * @returns An array of the rows.
       */
      getRows() {
        return this._rows.slice();
      }
      /**
       * Gets the delimiter row of the table.
       *
       * @returns The delimiter row; `undefined` if there is not delimiter row.
       */
      getDelimiterRow() {
        const row = this._rows[1];
        if (row === void 0) {
          return void 0;
        }
        if (row.isDelimiter()) {
          return row;
        }
        return void 0;
      }
      /**
       * Gets a cell at the specified index.
       *
       * @param rowIndex - Row index of the cell.
       * @param columnIndex - Column index of the cell.
       * @returns The cell at the specified index; `undefined` if not found.
       */
      getCellAt(rowIndex, columnIndex) {
        const row = this._rows[rowIndex];
        if (row === void 0) {
          return void 0;
        }
        return row.getCellAt(columnIndex);
      }
      /**
       * Gets the cell at the focus.
       *
       * @param focus - Focus object.
       * @returns The cell at the focus; `undefined` if not found.
       */
      getFocusedCell(focus) {
        return this.getCellAt(focus.row, focus.column);
      }
      /**
       * Converts the table to an array of text representations of the rows.
       *
       * @returns An array of text representations of the rows.
       */
      toLines() {
        return this._rows.map((row) => row.toText());
      }
      /**
       * Sets a cell in the table to a new value, returning a copy of the table
       * with the modified value.
       *
       * If an invalid index is provided, the table will be unchanged.
       */
      setCellAt(rowIndex, columnIndex, value) {
        const rows = this.getRows();
        rows[rowIndex] = rows[rowIndex].setCellAt(columnIndex, value);
        return new _Table(rows);
      }
      /**
       * Computes a focus from a point in the text editor.
       *
       * @param pos - A point in the text editor.
       * @param rowOffset - The row index where the table starts in the text editor.
       * @returns A focus object that corresponds to the specified point;
       * `undefined` if the row index is out of bounds.
       */
      focusOfPosition(pos, rowOffset) {
        const rowIndex = pos.row - rowOffset;
        const row = this._rows[rowIndex];
        if (row === void 0) {
          return void 0;
        }
        if (pos.column < row.marginLeft.length + 1) {
          return new focus_1.Focus(rowIndex, -1, pos.column);
        }
        const cellWidths = row.getCells().map((cell) => cell.rawContent.length);
        let columnPos = row.marginLeft.length + 1;
        let columnIndex = 0;
        for (; columnIndex < cellWidths.length; columnIndex++) {
          if (columnPos + cellWidths[columnIndex] + 1 > pos.column) {
            break;
          }
          columnPos += cellWidths[columnIndex] + 1;
        }
        const offset = pos.column - columnPos;
        return new focus_1.Focus(rowIndex, columnIndex, offset);
      }
      /**
       * Computes a position in the text editor from a focus.
       *
       * @param focus - A focus object.
       * @param rowOffset - The row index where the table starts in the text editor.
       * @returns A position in the text editor that corresponds to the focus;
       * `undefined` if the focused row  is out of the table.
       */
      positionOfFocus(focus, rowOffset) {
        const row = this._rows[focus.row];
        if (row === void 0) {
          return void 0;
        }
        const rowPos = focus.row + rowOffset;
        if (focus.column < 0) {
          return new point_1.Point(rowPos, focus.offset);
        }
        const cellWidths = row.getCells().map((cell) => cell.rawContent.length);
        const maxIndex = Math.min(focus.column, cellWidths.length);
        let columnPos = row.marginLeft.length + 1;
        for (let columnIndex = 0; columnIndex < maxIndex; columnIndex++) {
          columnPos += cellWidths[columnIndex] + 1;
        }
        return new point_1.Point(rowPos, columnPos + focus.offset);
      }
      /**
       * Computes a selection range from a focus.
       *
       * @param focus - A focus object.
       * @param rowOffset - The row index where the table starts in the text editor.
       * @returns A range to be selected that corresponds to the focus;
       * `undefined` if the focus does not specify any cell or the specified cell is empty.
       */
      selectionRangeOfFocus(focus, rowOffset) {
        const row = this._rows[focus.row];
        if (row === void 0) {
          return void 0;
        }
        const cell = row.getCellAt(focus.column);
        if (cell === void 0) {
          return void 0;
        }
        if (cell.content === "") {
          return void 0;
        }
        const rowPos = focus.row + rowOffset;
        const cellWidths = row.getCells().map((cell2) => cell2.rawContent.length);
        let columnPos = row.marginLeft.length + 1;
        for (let columnIndex = 0; columnIndex < focus.column; columnIndex++) {
          columnPos += cellWidths[columnIndex] + 1;
        }
        columnPos += cell.paddingLeft;
        return new range_1.Range(new point_1.Point(rowPos, columnPos), new point_1.Point(rowPos, columnPos + cell.content.length));
      }
      /**
       * Evaluate the formula, applying the results to this table and returning the
       * changes as a new table.
       */
      applyFormulas(formulaLines) {
        return (0, calc_1.parseAndApply)(formulaLines, this);
      }
    };
    exports.Table = Table;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/parser.js
var require_parser = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.readTable = exports._marginRegex = exports.marginRegexSrc = exports._readRow = exports._splitCells = void 0;
    var table_1 = require_table();
    var table_cell_1 = require_table_cell();
    var table_row_1 = require_table_row();
    var _splitCells = (text) => {
      const cells = [];
      let buf = "";
      let rest = text;
      while (rest !== "") {
        switch (rest[0]) {
          case "`":
            {
              const startMatch = rest.match(/^`*/);
              if (startMatch === null) {
                break;
              }
              const start = startMatch[0];
              let buf1 = start;
              let rest1 = rest.substr(start.length);
              let closed = false;
              while (rest1 !== "") {
                if (rest1[0] === "`") {
                  const endMatch = rest1.match(/^`*/);
                  if (endMatch === null) {
                    break;
                  }
                  const end = endMatch[0];
                  buf1 += end;
                  rest1 = rest1.substr(end.length);
                  if (end.length === start.length) {
                    closed = true;
                    break;
                  }
                } else {
                  buf1 += rest1[0];
                  rest1 = rest1.substr(1);
                }
              }
              if (closed) {
                buf += buf1;
                rest = rest1;
              } else {
                buf += "`";
                rest = rest.substr(1);
              }
            }
            break;
          case "\\":
            if (rest.length >= 2) {
              buf += rest.substr(0, 2);
              rest = rest.substr(2);
            } else {
              buf += "\\";
              rest = rest.substr(1);
            }
            break;
          case "[":
            buf += "[";
            rest = rest.substr(1);
            if (/\[[^\\|\]]+\|[^|\]]+]]/.test(rest)) {
              const idx = rest.indexOf("|");
              buf += rest.slice(0, idx);
              buf += "\\|";
              rest = rest.substr(idx + 1);
            }
            break;
          case "|":
            cells.push(buf);
            buf = "";
            rest = rest.substr(1);
            break;
          default:
            buf += rest[0];
            rest = rest.substr(1);
        }
      }
      cells.push(buf);
      return cells;
    };
    exports._splitCells = _splitCells;
    var _readRow = (text, leftMarginRegex = /^\s*$/) => {
      let cells = (0, exports._splitCells)(text);
      let marginLeft;
      if (cells.length > 0 && leftMarginRegex.test(cells[0])) {
        marginLeft = cells[0];
        cells = cells.slice(1);
      } else {
        marginLeft = "";
      }
      let marginRight;
      if (cells.length > 1 && /^\s*$/.test(cells[cells.length - 1])) {
        marginRight = cells[cells.length - 1];
        cells = cells.slice(0, cells.length - 1);
      } else {
        marginRight = "";
      }
      return new table_row_1.TableRow(cells.map((cell) => new table_cell_1.TableCell(cell)), marginLeft, marginRight);
    };
    exports._readRow = _readRow;
    var marginRegexSrc = (chars) => {
      let cs = "";
      chars.forEach((c) => {
        if (c !== "|" && c !== "\\" && c !== "`") {
          cs += `\\u{${c.codePointAt(0).toString(16)}}`;
        }
      });
      return `[\\s${cs}]*`;
    };
    exports.marginRegexSrc = marginRegexSrc;
    var _marginRegex = (chars) => new RegExp(`^${(0, exports.marginRegexSrc)(chars)}$`, "u");
    exports._marginRegex = _marginRegex;
    var readTable = (lines, options) => {
      const leftMarginRegex = (0, exports._marginRegex)(options.leftMarginChars);
      return new table_1.Table(lines.map((line) => (0, exports._readRow)(line, leftMarginRegex)));
    };
    exports.readTable = readTable;
  }
});

// node_modules/meaw/lib/index.js
var require_lib = __commonJS({
  "node_modules/meaw/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defs = [
      [0, 31, "N"],
      [32, 126, "Na"],
      [127, 160, "N"],
      [161, 161, "A"],
      [162, 163, "Na"],
      [164, 164, "A"],
      [165, 166, "Na"],
      [167, 168, "A"],
      [169, 169, "N"],
      [170, 170, "A"],
      [171, 171, "N"],
      [172, 172, "Na"],
      [173, 174, "A"],
      [175, 175, "Na"],
      [176, 180, "A"],
      [181, 181, "N"],
      [182, 186, "A"],
      [187, 187, "N"],
      [188, 191, "A"],
      [192, 197, "N"],
      [198, 198, "A"],
      [199, 207, "N"],
      [208, 208, "A"],
      [209, 214, "N"],
      [215, 216, "A"],
      [217, 221, "N"],
      [222, 225, "A"],
      [226, 229, "N"],
      [230, 230, "A"],
      [231, 231, "N"],
      [232, 234, "A"],
      [235, 235, "N"],
      [236, 237, "A"],
      [238, 239, "N"],
      [240, 240, "A"],
      [241, 241, "N"],
      [242, 243, "A"],
      [244, 246, "N"],
      [247, 250, "A"],
      [251, 251, "N"],
      [252, 252, "A"],
      [253, 253, "N"],
      [254, 254, "A"],
      [255, 256, "N"],
      [257, 257, "A"],
      [258, 272, "N"],
      [273, 273, "A"],
      [274, 274, "N"],
      [275, 275, "A"],
      [276, 282, "N"],
      [283, 283, "A"],
      [284, 293, "N"],
      [294, 295, "A"],
      [296, 298, "N"],
      [299, 299, "A"],
      [300, 304, "N"],
      [305, 307, "A"],
      [308, 311, "N"],
      [312, 312, "A"],
      [313, 318, "N"],
      [319, 322, "A"],
      [323, 323, "N"],
      [324, 324, "A"],
      [325, 327, "N"],
      [328, 331, "A"],
      [332, 332, "N"],
      [333, 333, "A"],
      [334, 337, "N"],
      [338, 339, "A"],
      [340, 357, "N"],
      [358, 359, "A"],
      [360, 362, "N"],
      [363, 363, "A"],
      [364, 461, "N"],
      [462, 462, "A"],
      [463, 463, "N"],
      [464, 464, "A"],
      [465, 465, "N"],
      [466, 466, "A"],
      [467, 467, "N"],
      [468, 468, "A"],
      [469, 469, "N"],
      [470, 470, "A"],
      [471, 471, "N"],
      [472, 472, "A"],
      [473, 473, "N"],
      [474, 474, "A"],
      [475, 475, "N"],
      [476, 476, "A"],
      [477, 592, "N"],
      [593, 593, "A"],
      [594, 608, "N"],
      [609, 609, "A"],
      [610, 707, "N"],
      [708, 708, "A"],
      [709, 710, "N"],
      [711, 711, "A"],
      [712, 712, "N"],
      [713, 715, "A"],
      [716, 716, "N"],
      [717, 717, "A"],
      [718, 719, "N"],
      [720, 720, "A"],
      [721, 727, "N"],
      [728, 731, "A"],
      [732, 732, "N"],
      [733, 733, "A"],
      [734, 734, "N"],
      [735, 735, "A"],
      [736, 767, "N"],
      [768, 879, "A"],
      [880, 912, "N"],
      [913, 929, "A"],
      [930, 930, "N"],
      [931, 937, "A"],
      [938, 944, "N"],
      [945, 961, "A"],
      [962, 962, "N"],
      [963, 969, "A"],
      [970, 1024, "N"],
      [1025, 1025, "A"],
      [1026, 1039, "N"],
      [1040, 1103, "A"],
      [1104, 1104, "N"],
      [1105, 1105, "A"],
      [1106, 4351, "N"],
      [4352, 4447, "W"],
      [4448, 8207, "N"],
      [8208, 8208, "A"],
      [8209, 8210, "N"],
      [8211, 8214, "A"],
      [8215, 8215, "N"],
      [8216, 8217, "A"],
      [8218, 8219, "N"],
      [8220, 8221, "A"],
      [8222, 8223, "N"],
      [8224, 8226, "A"],
      [8227, 8227, "N"],
      [8228, 8231, "A"],
      [8232, 8239, "N"],
      [8240, 8240, "A"],
      [8241, 8241, "N"],
      [8242, 8243, "A"],
      [8244, 8244, "N"],
      [8245, 8245, "A"],
      [8246, 8250, "N"],
      [8251, 8251, "A"],
      [8252, 8253, "N"],
      [8254, 8254, "A"],
      [8255, 8307, "N"],
      [8308, 8308, "A"],
      [8309, 8318, "N"],
      [8319, 8319, "A"],
      [8320, 8320, "N"],
      [8321, 8324, "A"],
      [8325, 8360, "N"],
      [8361, 8361, "H"],
      [8362, 8363, "N"],
      [8364, 8364, "A"],
      [8365, 8450, "N"],
      [8451, 8451, "A"],
      [8452, 8452, "N"],
      [8453, 8453, "A"],
      [8454, 8456, "N"],
      [8457, 8457, "A"],
      [8458, 8466, "N"],
      [8467, 8467, "A"],
      [8468, 8469, "N"],
      [8470, 8470, "A"],
      [8471, 8480, "N"],
      [8481, 8482, "A"],
      [8483, 8485, "N"],
      [8486, 8486, "A"],
      [8487, 8490, "N"],
      [8491, 8491, "A"],
      [8492, 8530, "N"],
      [8531, 8532, "A"],
      [8533, 8538, "N"],
      [8539, 8542, "A"],
      [8543, 8543, "N"],
      [8544, 8555, "A"],
      [8556, 8559, "N"],
      [8560, 8569, "A"],
      [8570, 8584, "N"],
      [8585, 8585, "A"],
      [8586, 8591, "N"],
      [8592, 8601, "A"],
      [8602, 8631, "N"],
      [8632, 8633, "A"],
      [8634, 8657, "N"],
      [8658, 8658, "A"],
      [8659, 8659, "N"],
      [8660, 8660, "A"],
      [8661, 8678, "N"],
      [8679, 8679, "A"],
      [8680, 8703, "N"],
      [8704, 8704, "A"],
      [8705, 8705, "N"],
      [8706, 8707, "A"],
      [8708, 8710, "N"],
      [8711, 8712, "A"],
      [8713, 8714, "N"],
      [8715, 8715, "A"],
      [8716, 8718, "N"],
      [8719, 8719, "A"],
      [8720, 8720, "N"],
      [8721, 8721, "A"],
      [8722, 8724, "N"],
      [8725, 8725, "A"],
      [8726, 8729, "N"],
      [8730, 8730, "A"],
      [8731, 8732, "N"],
      [8733, 8736, "A"],
      [8737, 8738, "N"],
      [8739, 8739, "A"],
      [8740, 8740, "N"],
      [8741, 8741, "A"],
      [8742, 8742, "N"],
      [8743, 8748, "A"],
      [8749, 8749, "N"],
      [8750, 8750, "A"],
      [8751, 8755, "N"],
      [8756, 8759, "A"],
      [8760, 8763, "N"],
      [8764, 8765, "A"],
      [8766, 8775, "N"],
      [8776, 8776, "A"],
      [8777, 8779, "N"],
      [8780, 8780, "A"],
      [8781, 8785, "N"],
      [8786, 8786, "A"],
      [8787, 8799, "N"],
      [8800, 8801, "A"],
      [8802, 8803, "N"],
      [8804, 8807, "A"],
      [8808, 8809, "N"],
      [8810, 8811, "A"],
      [8812, 8813, "N"],
      [8814, 8815, "A"],
      [8816, 8833, "N"],
      [8834, 8835, "A"],
      [8836, 8837, "N"],
      [8838, 8839, "A"],
      [8840, 8852, "N"],
      [8853, 8853, "A"],
      [8854, 8856, "N"],
      [8857, 8857, "A"],
      [8858, 8868, "N"],
      [8869, 8869, "A"],
      [8870, 8894, "N"],
      [8895, 8895, "A"],
      [8896, 8977, "N"],
      [8978, 8978, "A"],
      [8979, 8985, "N"],
      [8986, 8987, "W"],
      [8988, 9e3, "N"],
      [9001, 9002, "W"],
      [9003, 9192, "N"],
      [9193, 9196, "W"],
      [9197, 9199, "N"],
      [9200, 9200, "W"],
      [9201, 9202, "N"],
      [9203, 9203, "W"],
      [9204, 9311, "N"],
      [9312, 9449, "A"],
      [9450, 9450, "N"],
      [9451, 9547, "A"],
      [9548, 9551, "N"],
      [9552, 9587, "A"],
      [9588, 9599, "N"],
      [9600, 9615, "A"],
      [9616, 9617, "N"],
      [9618, 9621, "A"],
      [9622, 9631, "N"],
      [9632, 9633, "A"],
      [9634, 9634, "N"],
      [9635, 9641, "A"],
      [9642, 9649, "N"],
      [9650, 9651, "A"],
      [9652, 9653, "N"],
      [9654, 9655, "A"],
      [9656, 9659, "N"],
      [9660, 9661, "A"],
      [9662, 9663, "N"],
      [9664, 9665, "A"],
      [9666, 9669, "N"],
      [9670, 9672, "A"],
      [9673, 9674, "N"],
      [9675, 9675, "A"],
      [9676, 9677, "N"],
      [9678, 9681, "A"],
      [9682, 9697, "N"],
      [9698, 9701, "A"],
      [9702, 9710, "N"],
      [9711, 9711, "A"],
      [9712, 9724, "N"],
      [9725, 9726, "W"],
      [9727, 9732, "N"],
      [9733, 9734, "A"],
      [9735, 9736, "N"],
      [9737, 9737, "A"],
      [9738, 9741, "N"],
      [9742, 9743, "A"],
      [9744, 9747, "N"],
      [9748, 9749, "W"],
      [9750, 9755, "N"],
      [9756, 9756, "A"],
      [9757, 9757, "N"],
      [9758, 9758, "A"],
      [9759, 9791, "N"],
      [9792, 9792, "A"],
      [9793, 9793, "N"],
      [9794, 9794, "A"],
      [9795, 9799, "N"],
      [9800, 9811, "W"],
      [9812, 9823, "N"],
      [9824, 9825, "A"],
      [9826, 9826, "N"],
      [9827, 9829, "A"],
      [9830, 9830, "N"],
      [9831, 9834, "A"],
      [9835, 9835, "N"],
      [9836, 9837, "A"],
      [9838, 9838, "N"],
      [9839, 9839, "A"],
      [9840, 9854, "N"],
      [9855, 9855, "W"],
      [9856, 9874, "N"],
      [9875, 9875, "W"],
      [9876, 9885, "N"],
      [9886, 9887, "A"],
      [9888, 9888, "N"],
      [9889, 9889, "W"],
      [9890, 9897, "N"],
      [9898, 9899, "W"],
      [9900, 9916, "N"],
      [9917, 9918, "W"],
      [9919, 9919, "A"],
      [9920, 9923, "N"],
      [9924, 9925, "W"],
      [9926, 9933, "A"],
      [9934, 9934, "W"],
      [9935, 9939, "A"],
      [9940, 9940, "W"],
      [9941, 9953, "A"],
      [9954, 9954, "N"],
      [9955, 9955, "A"],
      [9956, 9959, "N"],
      [9960, 9961, "A"],
      [9962, 9962, "W"],
      [9963, 9969, "A"],
      [9970, 9971, "W"],
      [9972, 9972, "A"],
      [9973, 9973, "W"],
      [9974, 9977, "A"],
      [9978, 9978, "W"],
      [9979, 9980, "A"],
      [9981, 9981, "W"],
      [9982, 9983, "A"],
      [9984, 9988, "N"],
      [9989, 9989, "W"],
      [9990, 9993, "N"],
      [9994, 9995, "W"],
      [9996, 10023, "N"],
      [10024, 10024, "W"],
      [10025, 10044, "N"],
      [10045, 10045, "A"],
      [10046, 10059, "N"],
      [10060, 10060, "W"],
      [10061, 10061, "N"],
      [10062, 10062, "W"],
      [10063, 10066, "N"],
      [10067, 10069, "W"],
      [10070, 10070, "N"],
      [10071, 10071, "W"],
      [10072, 10101, "N"],
      [10102, 10111, "A"],
      [10112, 10132, "N"],
      [10133, 10135, "W"],
      [10136, 10159, "N"],
      [10160, 10160, "W"],
      [10161, 10174, "N"],
      [10175, 10175, "W"],
      [10176, 10213, "N"],
      [10214, 10221, "Na"],
      [10222, 10628, "N"],
      [10629, 10630, "Na"],
      [10631, 11034, "N"],
      [11035, 11036, "W"],
      [11037, 11087, "N"],
      [11088, 11088, "W"],
      [11089, 11092, "N"],
      [11093, 11093, "W"],
      [11094, 11097, "A"],
      [11098, 11903, "N"],
      [11904, 11929, "W"],
      [11930, 11930, "N"],
      [11931, 12019, "W"],
      [12020, 12031, "N"],
      [12032, 12245, "W"],
      [12246, 12271, "N"],
      [12272, 12283, "W"],
      [12284, 12287, "N"],
      [12288, 12288, "F"],
      [12289, 12350, "W"],
      [12351, 12352, "N"],
      [12353, 12438, "W"],
      [12439, 12440, "N"],
      [12441, 12543, "W"],
      [12544, 12548, "N"],
      [12549, 12591, "W"],
      [12592, 12592, "N"],
      [12593, 12686, "W"],
      [12687, 12687, "N"],
      [12688, 12771, "W"],
      [12772, 12783, "N"],
      [12784, 12830, "W"],
      [12831, 12831, "N"],
      [12832, 12871, "W"],
      [12872, 12879, "A"],
      [12880, 19903, "W"],
      [19904, 19967, "N"],
      [19968, 42124, "W"],
      [42125, 42127, "N"],
      [42128, 42182, "W"],
      [42183, 43359, "N"],
      [43360, 43388, "W"],
      [43389, 44031, "N"],
      [44032, 55203, "W"],
      [55204, 57343, "N"],
      [57344, 63743, "A"],
      [63744, 64255, "W"],
      [64256, 65023, "N"],
      [65024, 65039, "A"],
      [65040, 65049, "W"],
      [65050, 65071, "N"],
      [65072, 65106, "W"],
      [65107, 65107, "N"],
      [65108, 65126, "W"],
      [65127, 65127, "N"],
      [65128, 65131, "W"],
      [65132, 65280, "N"],
      [65281, 65376, "F"],
      [65377, 65470, "H"],
      [65471, 65473, "N"],
      [65474, 65479, "H"],
      [65480, 65481, "N"],
      [65482, 65487, "H"],
      [65488, 65489, "N"],
      [65490, 65495, "H"],
      [65496, 65497, "N"],
      [65498, 65500, "H"],
      [65501, 65503, "N"],
      [65504, 65510, "F"],
      [65511, 65511, "N"],
      [65512, 65518, "H"],
      [65519, 65532, "N"],
      [65533, 65533, "A"],
      [65534, 94175, "N"],
      [94176, 94180, "W"],
      [94181, 94191, "N"],
      [94192, 94193, "W"],
      [94194, 94207, "N"],
      [94208, 100343, "W"],
      [100344, 100351, "N"],
      [100352, 101589, "W"],
      [101590, 101631, "N"],
      [101632, 101640, "W"],
      [101641, 110591, "N"],
      [110592, 110878, "W"],
      [110879, 110927, "N"],
      [110928, 110930, "W"],
      [110931, 110947, "N"],
      [110948, 110951, "W"],
      [110952, 110959, "N"],
      [110960, 111355, "W"],
      [111356, 126979, "N"],
      [126980, 126980, "W"],
      [126981, 127182, "N"],
      [127183, 127183, "W"],
      [127184, 127231, "N"],
      [127232, 127242, "A"],
      [127243, 127247, "N"],
      [127248, 127277, "A"],
      [127278, 127279, "N"],
      [127280, 127337, "A"],
      [127338, 127343, "N"],
      [127344, 127373, "A"],
      [127374, 127374, "W"],
      [127375, 127376, "A"],
      [127377, 127386, "W"],
      [127387, 127404, "A"],
      [127405, 127487, "N"],
      [127488, 127490, "W"],
      [127491, 127503, "N"],
      [127504, 127547, "W"],
      [127548, 127551, "N"],
      [127552, 127560, "W"],
      [127561, 127567, "N"],
      [127568, 127569, "W"],
      [127570, 127583, "N"],
      [127584, 127589, "W"],
      [127590, 127743, "N"],
      [127744, 127776, "W"],
      [127777, 127788, "N"],
      [127789, 127797, "W"],
      [127798, 127798, "N"],
      [127799, 127868, "W"],
      [127869, 127869, "N"],
      [127870, 127891, "W"],
      [127892, 127903, "N"],
      [127904, 127946, "W"],
      [127947, 127950, "N"],
      [127951, 127955, "W"],
      [127956, 127967, "N"],
      [127968, 127984, "W"],
      [127985, 127987, "N"],
      [127988, 127988, "W"],
      [127989, 127991, "N"],
      [127992, 128062, "W"],
      [128063, 128063, "N"],
      [128064, 128064, "W"],
      [128065, 128065, "N"],
      [128066, 128252, "W"],
      [128253, 128254, "N"],
      [128255, 128317, "W"],
      [128318, 128330, "N"],
      [128331, 128334, "W"],
      [128335, 128335, "N"],
      [128336, 128359, "W"],
      [128360, 128377, "N"],
      [128378, 128378, "W"],
      [128379, 128404, "N"],
      [128405, 128406, "W"],
      [128407, 128419, "N"],
      [128420, 128420, "W"],
      [128421, 128506, "N"],
      [128507, 128591, "W"],
      [128592, 128639, "N"],
      [128640, 128709, "W"],
      [128710, 128715, "N"],
      [128716, 128716, "W"],
      [128717, 128719, "N"],
      [128720, 128722, "W"],
      [128723, 128724, "N"],
      [128725, 128727, "W"],
      [128728, 128746, "N"],
      [128747, 128748, "W"],
      [128749, 128755, "N"],
      [128756, 128764, "W"],
      [128765, 128991, "N"],
      [128992, 129003, "W"],
      [129004, 129291, "N"],
      [129292, 129338, "W"],
      [129339, 129339, "N"],
      [129340, 129349, "W"],
      [129350, 129350, "N"],
      [129351, 129400, "W"],
      [129401, 129401, "N"],
      [129402, 129483, "W"],
      [129484, 129484, "N"],
      [129485, 129535, "W"],
      [129536, 129647, "N"],
      [129648, 129652, "W"],
      [129653, 129655, "N"],
      [129656, 129658, "W"],
      [129659, 129663, "N"],
      [129664, 129670, "W"],
      [129671, 129679, "N"],
      [129680, 129704, "W"],
      [129705, 129711, "N"],
      [129712, 129718, "W"],
      [129719, 129727, "N"],
      [129728, 129730, "W"],
      [129731, 129743, "N"],
      [129744, 129750, "W"],
      [129751, 131071, "N"],
      [131072, 196605, "W"],
      [196606, 196607, "N"],
      [196608, 262141, "W"],
      [262142, 917759, "N"],
      [917760, 917999, "A"],
      [918e3, 983039, "N"],
      [983040, 1048573, "A"],
      [1048574, 1048575, "N"],
      [1048576, 1114109, "A"],
      [1114110, 1114111, "N"]
    ];
    var version = "13.0.0";
    function getEAWOfCodePoint(codePoint) {
      var min = 0;
      var max = defs.length - 1;
      while (min !== max) {
        var i = min + (max - min >> 1);
        var _a = defs[i], start = _a[0], end = _a[1], prop = _a[2];
        if (codePoint < start) {
          max = i - 1;
        } else if (codePoint > end) {
          min = i + 1;
        } else {
          return prop;
        }
      }
      return defs[min][2];
    }
    function getEAW(str, pos) {
      if (pos === void 0) {
        pos = 0;
      }
      var codePoint = str.codePointAt(pos);
      if (codePoint === void 0) {
        return void 0;
      }
      return getEAWOfCodePoint(codePoint);
    }
    var defaultWidths = {
      N: 1,
      Na: 1,
      W: 2,
      F: 2,
      H: 1,
      A: 1
    };
    function computeWidth(str, widths) {
      var width = 0;
      for (var _i = 0, str_1 = str; _i < str_1.length; _i++) {
        var char = str_1[_i];
        var eaw = getEAW(char);
        width += widths && widths[eaw] || defaultWidths[eaw];
      }
      return width;
    }
    exports.computeWidth = computeWidth;
    exports.eawVersion = version;
    exports.getEAW = getEAW;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/formatter.js
var require_formatter = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/formatter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.moveColumn = exports.deleteColumn = exports.insertColumn = exports.moveRow = exports.deleteRow = exports.insertRow = exports.alterAlignment = exports.formatTable = exports.FormatType = exports._weakFormatTable = exports._formatTable = exports._padText = exports._alignText = exports._computeTextWidth = exports.completeTable = exports._extendArray = exports._delimiterText = void 0;
    var alignment_1 = require_alignment();
    var table_1 = require_table();
    var table_cell_1 = require_table_cell();
    var table_row_1 = require_table_row();
    var meaw_1 = require_lib();
    var _delimiterText = (alignment, width) => {
      const bar = "-".repeat(width);
      switch (alignment) {
        case alignment_1.Alignment.NONE:
          return ` ${bar} `;
        case alignment_1.Alignment.LEFT:
          return `:${bar} `;
        case alignment_1.Alignment.RIGHT:
          return ` ${bar}:`;
        case alignment_1.Alignment.CENTER:
          return `:${bar}:`;
        default:
          throw new Error("Unknown alignment: " + alignment);
      }
    };
    exports._delimiterText = _delimiterText;
    var _extendArray = (arr, size, callback) => {
      const extended = arr.slice();
      for (let i = arr.length; i < size; i++) {
        extended.push(callback(i, arr));
      }
      return extended;
    };
    exports._extendArray = _extendArray;
    var completeTable = (table, options) => {
      const tableHeight = table.getHeight();
      const tableWidth = table.getWidth();
      if (tableHeight === 0) {
        throw new Error("Empty table");
      }
      const rows = table.getRows();
      const newRows = [];
      const headerRow = rows[0];
      const headerCells = headerRow.getCells();
      newRows.push(new table_row_1.TableRow((0, exports._extendArray)(headerCells, tableWidth, (j) => new table_cell_1.TableCell(j === headerCells.length ? headerRow.marginRight : "")), headerRow.marginLeft, headerCells.length < tableWidth ? "" : headerRow.marginRight));
      const delimiterRow = table.getDelimiterRow();
      if (delimiterRow !== void 0) {
        const delimiterCells = delimiterRow.getCells();
        newRows.push(new table_row_1.TableRow((0, exports._extendArray)(delimiterCells, tableWidth, (j) => new table_cell_1.TableCell((0, exports._delimiterText)(alignment_1.Alignment.NONE, j === delimiterCells.length ? Math.max(options.minDelimiterWidth, delimiterRow.marginRight.length - 2) : options.minDelimiterWidth))), delimiterRow.marginLeft, delimiterCells.length < tableWidth ? "" : delimiterRow.marginRight));
      } else {
        newRows.push(new table_row_1.TableRow((0, exports._extendArray)([], tableWidth, () => new table_cell_1.TableCell((0, exports._delimiterText)(alignment_1.Alignment.NONE, options.minDelimiterWidth))), "", ""));
      }
      for (let i = delimiterRow !== void 0 ? 2 : 1; i < tableHeight; i++) {
        const row = rows[i];
        const cells = row.getCells();
        newRows.push(new table_row_1.TableRow((0, exports._extendArray)(cells, tableWidth, (j) => new table_cell_1.TableCell(j === cells.length ? row.marginRight : "")), row.marginLeft, cells.length < tableWidth ? "" : row.marginRight));
      }
      return {
        table: new table_1.Table(newRows),
        delimiterInserted: delimiterRow === void 0
      };
    };
    exports.completeTable = completeTable;
    var _computeTextWidth = (text, options) => {
      const normalized = options.normalize ? text.normalize("NFC") : text;
      let w = 0;
      for (const char of normalized) {
        if (options.wideChars.has(char)) {
          w += 2;
          continue;
        }
        if (options.narrowChars.has(char)) {
          w += 1;
          continue;
        }
        switch ((0, meaw_1.getEAW)(char)) {
          case "F":
          case "W":
            w += 2;
            break;
          case "A":
            w += options.ambiguousAsWide ? 2 : 1;
            break;
          default:
            w += 1;
        }
      }
      return w;
    };
    exports._computeTextWidth = _computeTextWidth;
    var _alignText = (text, width, alignment, options) => {
      const space = width - (0, exports._computeTextWidth)(text, options);
      if (space < 0) {
        return text;
      }
      switch (alignment) {
        case alignment_1.Alignment.NONE:
          throw new Error("Unexpected default alignment");
        case alignment_1.Alignment.LEFT:
          return text + " ".repeat(space);
        case alignment_1.Alignment.RIGHT:
          return " ".repeat(space) + text;
        case alignment_1.Alignment.CENTER:
          return " ".repeat(Math.floor(space / 2)) + text + " ".repeat(Math.ceil(space / 2));
        default:
          throw new Error("Unknown alignment: " + alignment);
      }
    };
    exports._alignText = _alignText;
    var _padText = (text) => ` ${text} `;
    exports._padText = _padText;
    var _formatTable = (table, options) => {
      const tableHeight = table.getHeight();
      const tableWidth = table.getWidth();
      if (tableHeight === 0) {
        return {
          table,
          marginLeft: ""
        };
      }
      const marginLeft = table.getRows()[0].marginLeft;
      if (tableWidth === 0) {
        const rows2 = new Array(tableHeight).fill(new table_row_1.TableRow([], marginLeft, ""));
        return {
          table: new table_1.Table(rows2),
          marginLeft
        };
      }
      const delimiterRow = table.getDelimiterRow();
      const columnWidths = new Array(tableWidth).fill(0);
      if (delimiterRow !== void 0) {
        const delimiterRowWidth = delimiterRow.getWidth();
        for (let j = 0; j < delimiterRowWidth; j++) {
          columnWidths[j] = options.minDelimiterWidth;
        }
      }
      for (let i = 0; i < tableHeight; i++) {
        if (delimiterRow !== void 0 && i === 1) {
          continue;
        }
        const row = table.getRows()[i];
        const rowWidth = row.getWidth();
        for (let j = 0; j < rowWidth; j++) {
          columnWidths[j] = Math.max(columnWidths[j], (0, exports._computeTextWidth)(row.getCellAt(j).content, options.textWidthOptions));
        }
      }
      const alignments = delimiterRow !== void 0 ? (0, exports._extendArray)(
        delimiterRow.getCells().map((cell) => cell.getAlignment()),
        tableWidth,
        // Safe conversion because DefaultAlignment is a subset of Alignment
        () => options.defaultAlignment
      ) : new Array(tableWidth).fill(options.defaultAlignment);
      const rows = [];
      const headerRow = table.getRows()[0];
      rows.push(new table_row_1.TableRow(headerRow.getCells().map((cell, j) => new table_cell_1.TableCell((0, exports._padText)((0, exports._alignText)(cell.content, columnWidths[j], options.headerAlignment === alignment_1.HeaderAlignment.FOLLOW ? alignments[j] === alignment_1.Alignment.NONE ? options.defaultAlignment : alignments[j] : options.headerAlignment, options.textWidthOptions)))), marginLeft, ""));
      if (delimiterRow !== void 0) {
        rows.push(new table_row_1.TableRow(delimiterRow.getCells().map((cell, j) => new table_cell_1.TableCell((0, exports._delimiterText)(alignments[j], columnWidths[j]))), marginLeft, ""));
      }
      for (let i = delimiterRow !== void 0 ? 2 : 1; i < tableHeight; i++) {
        const row = table.getRows()[i];
        rows.push(new table_row_1.TableRow(row.getCells().map((cell, j) => new table_cell_1.TableCell((0, exports._padText)((0, exports._alignText)(cell.content, columnWidths[j], alignments[j] === alignment_1.Alignment.NONE ? options.defaultAlignment : alignments[j], options.textWidthOptions)))), marginLeft, ""));
      }
      return {
        table: new table_1.Table(rows),
        marginLeft
      };
    };
    exports._formatTable = _formatTable;
    var _weakFormatTable = (table, options) => {
      const tableHeight = table.getHeight();
      const tableWidth = table.getWidth();
      if (tableHeight === 0) {
        return {
          table,
          marginLeft: ""
        };
      }
      const marginLeft = table.getRows()[0].marginLeft;
      if (tableWidth === 0) {
        const rows2 = new Array(tableHeight).fill(new table_row_1.TableRow([], marginLeft, ""));
        return {
          table: new table_1.Table(rows2),
          marginLeft
        };
      }
      const delimiterRow = table.getDelimiterRow();
      const rows = [];
      const headerRow = table.getRows()[0];
      rows.push(new table_row_1.TableRow(headerRow.getCells().map((cell) => new table_cell_1.TableCell((0, exports._padText)(cell.content))), marginLeft, ""));
      if (delimiterRow !== void 0) {
        rows.push(new table_row_1.TableRow(delimiterRow.getCells().map((cell) => new table_cell_1.TableCell((0, exports._delimiterText)(cell.getAlignment(), options.minDelimiterWidth))), marginLeft, ""));
      }
      for (let i = delimiterRow !== void 0 ? 2 : 1; i < tableHeight; i++) {
        const row = table.getRows()[i];
        rows.push(new table_row_1.TableRow(row.getCells().map((cell) => new table_cell_1.TableCell((0, exports._padText)(cell.content))), marginLeft, ""));
      }
      return {
        table: new table_1.Table(rows),
        marginLeft
      };
    };
    exports._weakFormatTable = _weakFormatTable;
    var FormatType3;
    (function(FormatType4) {
      FormatType4["NORMAL"] = "normal";
      FormatType4["WEAK"] = "weak";
    })(FormatType3 || (exports.FormatType = FormatType3 = {}));
    var formatTable = (table, options) => {
      switch (options.formatType) {
        case FormatType3.NORMAL:
          return (0, exports._formatTable)(table, options);
        case FormatType3.WEAK:
          return (0, exports._weakFormatTable)(table, options);
        default:
          throw new Error("Unknown format type: " + options.formatType);
      }
    };
    exports.formatTable = formatTable;
    var alterAlignment = (table, columnIndex, alignment, options) => {
      if (table.getHeight() < 1) {
        return table;
      }
      const delimiterRow = table.getRows()[1];
      if (columnIndex < 0 || delimiterRow.getWidth() - 1 < columnIndex) {
        return table;
      }
      const delimiterCells = delimiterRow.getCells();
      delimiterCells[columnIndex] = new table_cell_1.TableCell((0, exports._delimiterText)(alignment, options.minDelimiterWidth));
      const rows = table.getRows();
      rows[1] = new table_row_1.TableRow(delimiterCells, delimiterRow.marginLeft, delimiterRow.marginRight);
      return new table_1.Table(rows);
    };
    exports.alterAlignment = alterAlignment;
    var insertRow = (table, rowIndex, row) => {
      const rows = table.getRows();
      rows.splice(Math.max(rowIndex, 2), 0, row);
      return new table_1.Table(rows);
    };
    exports.insertRow = insertRow;
    var deleteRow = (table, rowIndex) => {
      if (rowIndex === 1) {
        return table;
      }
      const rows = table.getRows();
      if (rowIndex === 0) {
        const headerRow = rows[0];
        rows[0] = new table_row_1.TableRow(new Array(headerRow.getWidth()).fill(new table_cell_1.TableCell("")), headerRow.marginLeft, headerRow.marginRight);
      } else {
        rows.splice(rowIndex, 1);
      }
      return new table_1.Table(rows);
    };
    exports.deleteRow = deleteRow;
    var moveRow = (table, rowIndex, destIndex) => {
      if (rowIndex <= 1 || destIndex <= 1 || rowIndex === destIndex) {
        return table;
      }
      const rows = table.getRows();
      const row = rows[rowIndex];
      rows.splice(rowIndex, 1);
      rows.splice(destIndex, 0, row);
      return new table_1.Table(rows);
    };
    exports.moveRow = moveRow;
    var insertColumn = (table, columnIndex, column, options) => {
      const rows = table.getRows();
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = rows[i].getCells();
        const cell = i === 1 ? new table_cell_1.TableCell((0, exports._delimiterText)(alignment_1.Alignment.NONE, options.minDelimiterWidth)) : column[i > 1 ? i - 1 : i];
        cells.splice(columnIndex, 0, cell);
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
      }
      return new table_1.Table(rows);
    };
    exports.insertColumn = insertColumn;
    var deleteColumn = (table, columnIndex, options) => {
      const rows = table.getRows();
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        let cells = row.getCells();
        if (cells.length <= 1) {
          cells = [
            new table_cell_1.TableCell(i === 1 ? (0, exports._delimiterText)(alignment_1.Alignment.NONE, options.minDelimiterWidth) : "")
          ];
        } else {
          cells.splice(columnIndex, 1);
        }
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
      }
      return new table_1.Table(rows);
    };
    exports.deleteColumn = deleteColumn;
    var moveColumn = (table, columnIndex, destIndex) => {
      if (columnIndex === destIndex) {
        return table;
      }
      const rows = table.getRows();
      for (let i = 0; i < rows.length; i++) {
        const row = rows[i];
        const cells = row.getCells();
        const cell = cells[columnIndex];
        cells.splice(columnIndex, 1);
        cells.splice(destIndex, 0, cell);
        rows[i] = new table_row_1.TableRow(cells, row.marginLeft, row.marginRight);
      }
      return new table_1.Table(rows);
    };
    exports.moveColumn = moveColumn;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/edit-script.js
var require_edit_script = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/edit-script.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shortestEditScript = exports.applyEditScript = exports._applyCommand = exports.Delete = exports.Insert = void 0;
    var Insert = class {
      /**
       * Creats a new `Insert` object.
       *
       * @param row - Row index, starts from `0`.
       * @param line - A string to be inserted at the row.
       */
      constructor(row, line) {
        this.row = row;
        this.line = line;
      }
    };
    exports.Insert = Insert;
    var Delete = class {
      /**
       * Creates a new `Delete` object.
       *
       * @param row - Row index, starts from `0`.
       */
      constructor(row) {
        this.row = row;
      }
    };
    exports.Delete = Delete;
    var _applyCommand = (textEditor, command, rowOffset) => {
      if (command instanceof Insert) {
        textEditor.insertLine(rowOffset + command.row, command.line);
      } else if (command instanceof Delete) {
        textEditor.deleteLine(rowOffset + command.row);
      } else {
        throw new Error("Unknown command");
      }
    };
    exports._applyCommand = _applyCommand;
    var applyEditScript = (textEditor, script, rowOffset) => {
      for (const command of script) {
        (0, exports._applyCommand)(textEditor, command, rowOffset);
      }
    };
    exports.applyEditScript = applyEditScript;
    var IList = class {
      get car() {
        throw new Error("Not implemented");
      }
      get cdr() {
        throw new Error("Not implemented");
      }
      isEmpty() {
        throw new Error("Not implemented");
      }
      unshift(value) {
        return new Cons(value, this);
      }
      toArray() {
        const arr = [];
        let rest = this;
        while (!rest.isEmpty()) {
          arr.push(rest.car);
          rest = rest.cdr;
        }
        return arr;
      }
    };
    var Nil = class extends IList {
      constructor() {
        super();
      }
      get car() {
        throw new Error("Empty list");
      }
      get cdr() {
        throw new Error("Empty list");
      }
      isEmpty() {
        return true;
      }
    };
    var Cons = class extends IList {
      constructor(car, cdr) {
        super();
        this._car = car;
        this._cdr = cdr;
      }
      get car() {
        return this._car;
      }
      get cdr() {
        return this._cdr;
      }
      isEmpty() {
        return false;
      }
    };
    var shortestEditScript = (from, to, limit = -1) => {
      const fromLen = from.length;
      const toLen = to.length;
      const maxd = limit >= 0 ? Math.min(limit, fromLen + toLen) : fromLen + toLen;
      const mem = new Array(Math.min(maxd, fromLen) + Math.min(maxd, toLen) + 1);
      const offset = Math.min(maxd, fromLen);
      for (let d = 0; d <= maxd; d++) {
        const mink = d <= fromLen ? -d : d - 2 * fromLen;
        const maxk = d <= toLen ? d : -d + 2 * toLen;
        for (let k = mink; k <= maxk; k += 2) {
          let i;
          let script;
          if (d === 0) {
            i = 0;
            script = new Nil();
          } else if (k === -d) {
            i = mem[offset + k + 1].i + 1;
            script = mem[offset + k + 1].script.unshift(new Delete(i + k));
          } else if (k === d) {
            i = mem[offset + k - 1].i;
            script = mem[offset + k - 1].script.unshift(new Insert(i + k - 1, to[i + k - 1]));
          } else {
            const vi = mem[offset + k + 1].i + 1;
            const hi = mem[offset + k - 1].i;
            if (vi > hi) {
              i = vi;
              script = mem[offset + k + 1].script.unshift(new Delete(i + k));
            } else {
              i = hi;
              script = mem[offset + k - 1].script.unshift(new Insert(i + k - 1, to[i + k - 1]));
            }
          }
          while (i < fromLen && i + k < toLen && from[i] === to[i + k]) {
            i += 1;
          }
          if (k === toLen - fromLen && i === fromLen) {
            return script.toArray().reverse();
          }
          mem[offset + k] = { i, script };
        }
      }
      return void 0;
    };
    exports.shortestEditScript = shortestEditScript;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/text-editor.js
var require_text_editor = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/text-editor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ITextEditor = void 0;
    var ITextEditor = class {
      /**
       * Gets the current cursor position.
       *
       * @returns A point object that represents the cursor position.
       */
      getCursorPosition() {
        throw new Error("Not implemented: getCursorPosition");
      }
      /**
       * Sets the cursor position to a specified one.
       */
      setCursorPosition(pos) {
        throw new Error("Not implemented: setCursorPosition");
      }
      /**
       * Sets the selection range.
       * This method also expects the cursor position to be moved as the end of the selection range.
       */
      setSelectionRange(range) {
        throw new Error("Not implemented: setSelectionRange");
      }
      /**
       * Gets the last row index of the text editor.
       */
      getLastRow() {
        throw new Error("Not implemented: getLastRow");
      }
      /**
       * Checks if the editor accepts a table at a row to be editted.
       * It should return `false` if, for example, the row is in a code block (not Markdown).
       *
       * @param row - A row index in the text editor.
       * @returns `true` if the table at the row can be editted.
       */
      acceptsTableEdit(row) {
        throw new Error("Not implemented: acceptsTableEdit");
      }
      /**
       * Gets a line string at a row.
       *
       * @param row - Row index, starts from `0`.
       * @returns The line at the specified row.
       * The line must not contain an EOL like `"\n"` or `"\r"`.
       */
      getLine(row) {
        throw new Error("Not implemented: getLine");
      }
      /**
       * Inserts a line at a specified row.
       *
       * @param row - Row index, starts from `0`.
       * @param line - A string to be inserted.
       * This must not contain an EOL like `"\n"` or `"\r"`.
       */
      insertLine(row, line) {
        throw new Error("Not implemented: insertLine");
      }
      /**
       * Deletes a line at a specified row.
       *
       * @param row - Row index, starts from `0`.
       */
      deleteLine(row) {
        throw new Error("Not implemented: deleteLine");
      }
      /**
       * Replace lines in a specified range.
       *
       * @param startRow - Start row index, starts from `0`.
       * @param endRow - End row index.
       * Lines from `startRow` to `endRow - 1` is replaced.
       * @param lines - An array of string.
       * Each strings must not contain an EOL like `"\n"` or `"\r"`.
       */
      replaceLines(startRow, endRow, lines) {
        throw new Error("Not implemented: replaceLines");
      }
      /**
       * Batches multiple operations as a single undo/redo step.
       *
       * @param func - A callback function that executes some operations on the text editor.
       */
      transact(func) {
        throw new Error("Not implemented: transact");
      }
    };
    exports.ITextEditor = ITextEditor;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/options.js
var require_options = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defaultOptions = exports.optionsWithDefaults = void 0;
    var alignment_1 = require_alignment();
    var formatter_1 = require_formatter();
    var DEFAULT_TEXT_WIDTH_OPTIONS = {
      normalize: true,
      wideChars: /* @__PURE__ */ new Set(),
      narrowChars: /* @__PURE__ */ new Set(),
      ambiguousAsWide: false
    };
    var DEFAULT_OPTIONS = {
      leftMarginChars: /* @__PURE__ */ new Set(),
      formatType: formatter_1.FormatType.NORMAL,
      minDelimiterWidth: 3,
      defaultAlignment: alignment_1.DefaultAlignment.LEFT,
      headerAlignment: alignment_1.HeaderAlignment.FOLLOW,
      smartCursor: false
    };
    var optionsWithDefaults2 = (options) => Object.assign(Object.assign(Object.assign({}, DEFAULT_OPTIONS), options), { textWidthOptions: options.textWidthOptions ? Object.assign(Object.assign({}, DEFAULT_TEXT_WIDTH_OPTIONS), options.textWidthOptions) : DEFAULT_TEXT_WIDTH_OPTIONS });
    exports.optionsWithDefaults = optionsWithDefaults2;
    exports.defaultOptions = (0, exports.optionsWithDefaults)({});
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/table-editor.js
var require_table_editor = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/table-editor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TableEditor = exports._computeNewOffset = exports._createIsTableFormulaRegex = exports._createIsTableRowRegex = exports.SortOrder = void 0;
    var edit_script_1 = require_edit_script();
    var focus_1 = require_focus();
    var formatter_1 = require_formatter();
    var parser_1 = require_parser();
    var point_1 = require_point();
    var range_1 = require_range();
    var table_1 = require_table();
    var table_cell_1 = require_table_cell();
    var table_row_1 = require_table_row();
    var SortOrder2;
    (function(SortOrder3) {
      SortOrder3["Ascending"] = "ascending";
      SortOrder3["Descending"] = "descending";
    })(SortOrder2 || (exports.SortOrder = SortOrder2 = {}));
    var _createIsTableRowRegex = (leftMarginChars) => new RegExp(`^${(0, parser_1.marginRegexSrc)(leftMarginChars)}\\|`, "u");
    exports._createIsTableRowRegex = _createIsTableRowRegex;
    var _createIsTableFormulaRegex = (leftMarginChars) => new RegExp(`^${(0, parser_1.marginRegexSrc)(leftMarginChars)}<!-- ?.+-->$`, "u");
    exports._createIsTableFormulaRegex = _createIsTableFormulaRegex;
    var _computeNewOffset = (focus, table, formatted, moved) => {
      if (moved) {
        const formattedFocusedCell2 = formatted.table.getFocusedCell(focus);
        if (formattedFocusedCell2 !== void 0) {
          return formattedFocusedCell2.computeRawOffset(0);
        }
        return focus.column < 0 ? formatted.marginLeft.length : 0;
      }
      const focusedCell = table.getFocusedCell(focus);
      const formattedFocusedCell = formatted.table.getFocusedCell(focus);
      if (focusedCell !== void 0 && formattedFocusedCell !== void 0) {
        const contentOffset = Math.min(focusedCell.computeContentOffset(focus.offset), formattedFocusedCell.content.length);
        return formattedFocusedCell.computeRawOffset(contentOffset);
      }
      return focus.column < 0 ? formatted.marginLeft.length : 0;
    };
    exports._computeNewOffset = _computeNewOffset;
    var TableEditor2 = class {
      /**
       * Creates a new table editor instance.
       *
       * @param textEditor - A text editor interface.
       */
      constructor(textEditor) {
        this._textEditor = textEditor;
        this._scActive = false;
      }
      /**
       * Resets the smart cursor.
       * Call this method when the table editor is inactivated.
       */
      resetSmartCursor() {
        this._scActive = false;
      }
      /**
       * Checks if the cursor is in a table row. Returns false if the cursor is in a
       * table formula row (see cursorIsInTableFormula).
       * This is useful to check whether the table editor should be activated or not.
       *
       * @returns `true` if the cursor is in a table row.
       */
      cursorIsInTable(options) {
        const re = (0, exports._createIsTableRowRegex)(options.leftMarginChars);
        const pos = this._textEditor.getCursorPosition();
        return this._textEditor.acceptsTableEdit(pos.row) && re.test(this._textEditor.getLine(pos.row));
      }
      /**
       * Checks if the cursor is in a formula row below a table.
       * This is useful to check whether the table editor should be activated or not.
       *
       * @returns `true` if the cursor is in a formula row.
       */
      cursorIsInTableFormula(options) {
        const formulaRe = (0, exports._createIsTableFormulaRegex)(options.leftMarginChars);
        const pos = this._textEditor.getCursorPosition();
        return this._textEditor.acceptsTableEdit(pos.row) && formulaRe.test(this._textEditor.getLine(pos.row));
      }
      /**
       * Finds a table under the current cursor position.
       *
       * @returns undefined if there is no table or the determined focus is invalid.
       */
      _findTable(options) {
        const re = (0, exports._createIsTableRowRegex)(options.leftMarginChars);
        const formulaRe = (0, exports._createIsTableFormulaRegex)(options.leftMarginChars);
        let pos = this._textEditor.getCursorPosition();
        const lastRow = this._textEditor.getLastRow();
        const lines = [];
        const formulaLines = [];
        let startRow = pos.row;
        let endRow = pos.row;
        {
          let line = this._textEditor.getLine(pos.row);
          while (formulaRe.test(line) && pos.row >= 0) {
            pos = new point_1.Point(pos.row - 1, pos.column);
            endRow--;
            line = this._textEditor.getLine(pos.row);
          }
        }
        {
          const line = this._textEditor.getLine(pos.row);
          if (!this._textEditor.acceptsTableEdit(pos.row) || !re.test(line)) {
            return void 0;
          }
          lines.push(line);
        }
        for (let row = pos.row - 1; row >= 0; row--) {
          const line = this._textEditor.getLine(row);
          if (!this._textEditor.acceptsTableEdit(row) || !re.test(line)) {
            break;
          }
          lines.unshift(line);
          startRow = row;
        }
        for (let row = pos.row + 1; row <= lastRow; row++) {
          const line = this._textEditor.getLine(row);
          if (!this._textEditor.acceptsTableEdit(row) || !re.test(line)) {
            break;
          }
          lines.push(line);
          endRow = row;
        }
        for (let row = endRow + 1; row <= lastRow; row++) {
          const line = this._textEditor.getLine(row);
          if (!this._textEditor.acceptsTableEdit(row) || !formulaRe.test(line)) {
            break;
          }
          formulaLines.push(line);
        }
        const range = new range_1.Range(new point_1.Point(startRow, 0), new point_1.Point(endRow, lines[lines.length - 1].length));
        const table = (0, parser_1.readTable)(lines, options);
        const focus = table.focusOfPosition(pos, startRow);
        if (focus === void 0) {
          return void 0;
        }
        return { range, lines, formulaLines, table, focus };
      }
      /**
       * Finds a table and does an operation with it.
       *
       * @private
       * @param func - A function that does some operation on table information obtained by
       * {@link TableEditor#_findTable}.
       */
      _withTable(options, func) {
        const info = this._findTable(options);
        if (info === void 0) {
          return;
        }
        return func(info);
      }
      /**
       * Updates lines in a given range in the text editor.
       *
       * @private
       * @param startRow - Start row index, starts from `0`.
       * @param endRow - End row index.
       * Lines from `startRow` to `endRow - 1` are replaced.
       * @param newLines - New lines.
       * @param [oldLines=undefined] - Old lines to be replaced.
       */
      _updateLines(startRow, endRow, newLines, oldLines = void 0) {
        if (oldLines !== void 0) {
          const ses = (0, edit_script_1.shortestEditScript)(oldLines, newLines, 3);
          if (ses !== void 0) {
            (0, edit_script_1.applyEditScript)(this._textEditor, ses, startRow);
            return;
          }
        }
        this._textEditor.replaceLines(startRow, endRow, newLines);
      }
      /**
       * Moves the cursor position to the focused cell,
       *
       * @private
       * @param startRow - Row index where the table starts in the text editor.
       * @param table - A table.
       * @param focus - A focus to which the cursor will be moved.
       */
      _moveToFocus(startRow, table, focus) {
        const pos = table.positionOfFocus(focus, startRow);
        if (pos !== void 0) {
          this._textEditor.setCursorPosition(pos);
        }
      }
      /**
       * Selects the focused cell.
       * If the cell has no content to be selected, then just moves the cursor position.
       *
       * @private
       * @param startRow - Row index where the table starts in the text editor.
       * @param table - A table.
       * @param focus - A focus to be selected.
       */
      _selectFocus(startRow, table, focus) {
        const range = table.selectionRangeOfFocus(focus, startRow);
        if (range !== void 0) {
          this._textEditor.setSelectionRange(range);
        } else {
          this._moveToFocus(startRow, table, focus);
        }
      }
      /**
       * Formats the table under the cursor.
       */
      format(options) {
        this.withCompletedTable(options, ({ range, lines, table, focus }) => {
          const newFocus = focus;
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, table.toLines(), lines);
            this._moveToFocus(range.start.row, table, newFocus);
          });
        });
      }
      /**
       * Formats and escapes from the table.
       */
      escape(options) {
        this._withTable(options, ({ range, lines, table, focus }) => {
          const completed = (0, formatter_1.completeTable)(table, options);
          const formatted = (0, formatter_1.formatTable)(completed.table, options);
          const newRow = range.end.row + (completed.delimiterInserted ? 2 : 1);
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), lines);
            let newPos;
            if (newRow > this._textEditor.getLastRow()) {
              this._textEditor.insertLine(newRow, "");
              newPos = new point_1.Point(newRow, 0);
            } else {
              const re = new RegExp(`^${(0, parser_1.marginRegexSrc)(options.leftMarginChars)}`, "u");
              const nextLine = this._textEditor.getLine(newRow);
              const margin = re.exec(nextLine)[0];
              newPos = new point_1.Point(newRow, margin.length);
            }
            this._textEditor.setCursorPosition(newPos);
          });
          this.resetSmartCursor();
        });
      }
      /**
       * Alters the alignment of the focused column.
       */
      alignColumn(alignment, options) {
        this.withCompletedTable(options, ({ range, lines, table, focus }) => {
          let newFocus = focus;
          let altered = table;
          if (0 <= newFocus.column && newFocus.column <= altered.getHeaderWidth() - 1) {
            altered = (0, formatter_1.alterAlignment)(table, newFocus.column, alignment, options);
          }
          const formatted = (0, formatter_1.formatTable)(altered, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, table, formatted, false));
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), lines);
            this._moveToFocus(range.start.row, formatted.table, newFocus);
          });
        });
      }
      /**
       * Selects the focused cell content.
       */
      selectCell(options) {
        this.withCompletedTable(options, ({ range, lines, table, focus }) => {
          const newFocus = focus;
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, table.toLines(), lines);
            this._selectFocus(range.start.row, table, newFocus);
          });
        });
      }
      /**
       * Moves the focus to another cell.
       *
       * @param rowOffset - Offset in row.
       * @param columnOffset - Offset in column.
       */
      moveFocus(rowOffset, columnOffset, options) {
        this.withCompletedTable(options, ({ range, lines, table, focus }) => {
          let newFocus = focus;
          const startFocus = newFocus;
          if (rowOffset !== 0) {
            const height = table.getHeight();
            const skip = newFocus.row < 1 && newFocus.row + rowOffset >= 1 ? 1 : newFocus.row > 1 && newFocus.row + rowOffset <= 1 ? -1 : 0;
            newFocus = newFocus.setRow(Math.min(Math.max(newFocus.row + rowOffset + skip, 0), height <= 2 ? 0 : height - 1));
          }
          if (columnOffset !== 0) {
            const width = table.getHeaderWidth();
            if (!(newFocus.column < 0 && columnOffset < 0) && !(newFocus.column > width - 1 && columnOffset > 0)) {
              newFocus = newFocus.setColumn(Math.min(Math.max(newFocus.column + columnOffset, 0), width - 1));
            }
          }
          const moved = !newFocus.posEquals(startFocus);
          const formatted = (0, formatter_1.formatTable)(table, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, table, formatted, moved));
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), lines);
            if (moved) {
              this._selectFocus(range.start.row, formatted.table, newFocus);
            } else {
              this._moveToFocus(range.start.row, formatted.table, newFocus);
            }
          });
          if (moved) {
            this.resetSmartCursor();
          }
        });
      }
      /**
       * Moves the focus to the next cell.
       */
      nextCell(options) {
        this._withTable(options, ({ range, lines, table, focus }) => {
          const focusMoved = this._scTablePos !== void 0 && !range.start.equals(this._scTablePos) || this._scLastFocus !== void 0 && !focus.posEquals(this._scLastFocus);
          if (this._scActive && focusMoved) {
            this.resetSmartCursor();
          }
          let newFocus = focus;
          const completed = (0, formatter_1.completeTable)(table, options);
          if (completed.delimiterInserted && newFocus.row > 0) {
            newFocus = newFocus.setRow(newFocus.row + 1);
          }
          const startFocus = newFocus;
          let altered = completed.table;
          if (newFocus.row === 1) {
            newFocus = newFocus.setRow(2);
            if (options.smartCursor) {
              if (newFocus.column < 0 || altered.getHeaderWidth() - 1 < newFocus.column) {
                newFocus = newFocus.setColumn(0);
              }
            } else {
              newFocus = newFocus.setColumn(0);
            }
            if (newFocus.row > altered.getHeight() - 1) {
              const row = new Array(altered.getHeaderWidth()).fill(new table_cell_1.TableCell(""));
              altered = (0, formatter_1.insertRow)(altered, altered.getHeight(), new table_row_1.TableRow(row, "", ""));
            }
          } else {
            if (newFocus.column > altered.getHeaderWidth() - 1) {
              const column = new Array(altered.getHeight() - 1).fill(new table_cell_1.TableCell(""));
              altered = (0, formatter_1.insertColumn)(altered, altered.getHeaderWidth(), column, options);
            }
            newFocus = newFocus.setColumn(newFocus.column + 1);
          }
          const formatted = (0, formatter_1.formatTable)(altered, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, altered, formatted, true));
          const newLines = formatted.table.toLines();
          if (newFocus.column > formatted.table.getHeaderWidth() - 1) {
            newLines[newFocus.row] += " ";
            newFocus = newFocus.setOffset(1);
          }
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, newLines, lines);
            this._selectFocus(range.start.row, formatted.table, newFocus);
          });
          if (options.smartCursor) {
            if (!this._scActive) {
              this._scActive = true;
              this._scTablePos = range.start;
              if (startFocus.column < 0 || formatted.table.getHeaderWidth() - 1 < startFocus.column) {
                this._scStartFocus = new focus_1.Focus(startFocus.row, 0, 0);
              } else {
                this._scStartFocus = startFocus;
              }
            }
            this._scLastFocus = newFocus;
          }
        });
      }
      /**
       * Moves the focus to the previous cell.
       */
      previousCell(options) {
        this.withCompletedTable(options, ({ range, lines, table, focus }) => {
          let newFocus = focus;
          const startFocus = newFocus;
          if (newFocus.row === 0) {
            if (newFocus.column > 0) {
              newFocus = newFocus.setColumn(newFocus.column - 1);
            }
          } else if (newFocus.row === 1) {
            newFocus = new focus_1.Focus(0, table.getHeaderWidth() - 1, newFocus.offset);
          } else {
            if (newFocus.column > 0) {
              newFocus = newFocus.setColumn(newFocus.column - 1);
            } else {
              newFocus = new focus_1.Focus(newFocus.row === 2 ? 0 : newFocus.row - 1, table.getHeaderWidth() - 1, newFocus.offset);
            }
          }
          const moved = !newFocus.posEquals(startFocus);
          const formatted = (0, formatter_1.formatTable)(table, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, table, formatted, moved));
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), lines);
            if (moved) {
              this._selectFocus(range.start.row, formatted.table, newFocus);
            } else {
              this._moveToFocus(range.start.row, formatted.table, newFocus);
            }
          });
          if (moved) {
            this.resetSmartCursor();
          }
        });
      }
      /**
       * Moves the focus to the next row.
       */
      nextRow(options) {
        this._withTable(options, ({ range, lines, table, focus }) => {
          const focusMoved = this._scTablePos !== void 0 && !range.start.equals(this._scTablePos) || this._scLastFocus !== void 0 && !focus.posEquals(this._scLastFocus);
          if (this._scActive && focusMoved) {
            this.resetSmartCursor();
          }
          let newFocus = focus;
          const completed = (0, formatter_1.completeTable)(table, options);
          if (completed.delimiterInserted && newFocus.row > 0) {
            newFocus = newFocus.setRow(newFocus.row + 1);
          }
          const startFocus = newFocus;
          let altered = completed.table;
          if (newFocus.row === 0) {
            newFocus = newFocus.setRow(2);
          } else {
            newFocus = newFocus.setRow(newFocus.row + 1);
          }
          if (options.smartCursor) {
            if (this._scActive && this._scStartFocus !== void 0) {
              newFocus = newFocus.setColumn(this._scStartFocus.column);
            } else if (newFocus.column < 0 || altered.getHeaderWidth() - 1 < newFocus.column) {
              newFocus = newFocus.setColumn(0);
            }
          } else {
            newFocus = newFocus.setColumn(0);
          }
          if (newFocus.row > altered.getHeight() - 1) {
            const row = new Array(altered.getHeaderWidth()).fill(new table_cell_1.TableCell(""));
            altered = (0, formatter_1.insertRow)(altered, altered.getHeight(), new table_row_1.TableRow(row, "", ""));
          }
          const formatted = (0, formatter_1.formatTable)(altered, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, altered, formatted, true));
          this._textEditor.transact(() => {
            this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), lines);
            this._selectFocus(range.start.row, formatted.table, newFocus);
          });
          if (options.smartCursor) {
            if (!this._scActive) {
              this._scActive = true;
              this._scTablePos = range.start;
              if (startFocus.column < 0 || formatted.table.getHeaderWidth() - 1 < startFocus.column) {
                this._scStartFocus = new focus_1.Focus(startFocus.row, 0, 0);
              } else {
                this._scStartFocus = startFocus;
              }
            }
            this._scLastFocus = newFocus;
          }
        });
      }
      /**
       * Inserts an empty row at the current focus.
       */
      insertRow(options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          if (newFocus.row <= 1) {
            newFocus = newFocus.setRow(2);
          }
          newFocus = newFocus.setColumn(0);
          const row = new Array(table.getHeaderWidth()).fill(new table_cell_1.TableCell(""));
          const altered = (0, formatter_1.insertRow)(table, newFocus.row, new table_row_1.TableRow(row, "", ""));
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus);
        });
      }
      /**
       * Deletes a row at the current focus.
       */
      deleteRow(options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          let altered = table;
          let moved = false;
          if (newFocus.row !== 1) {
            altered = (0, formatter_1.deleteRow)(altered, newFocus.row);
            moved = true;
            if (newFocus.row > altered.getHeight() - 1) {
              newFocus = newFocus.setRow(newFocus.row === 2 ? 0 : newFocus.row - 1);
            }
          }
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus, moved);
        });
      }
      /**
       * Moves the focused row by the specified offset.
       *
       * @param offset - An offset the row is moved by.
       */
      moveRow(offset, options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          let altered = table;
          if (newFocus.row > 1) {
            const dest = Math.min(Math.max(newFocus.row + offset, 2), altered.getHeight() - 1);
            altered = (0, formatter_1.moveRow)(altered, newFocus.row, dest);
            newFocus = newFocus.setRow(dest);
          }
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus);
        });
      }
      evaluateFormulas(options) {
        return this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          const result = table.applyFormulas(formulaLines);
          if (result.isErr()) {
            return result.error;
          }
          const { table: formattedTable, focus: newFocus } = this.formatAndApply(options, range, lines, formulaLines, result.value, focus, false);
        });
      }
      /**
       * Transpose rows and columns of a table by inverting the X and Y axis values.
       * @param options
       */
      transpose(options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          const width = table.getWidth();
          const height = table.getHeight();
          const newRows = new Array(width + 1);
          for (let x = 0; x < width + 1; ++x) {
            if (x === 0) {
              const newRow = new Array(height - 1);
              for (let y = 0; y < height; ++y) {
                if (y === 0) {
                  const s = (_b = (_a = table.getCellAt(y, x)) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : "";
                  newRow[y] = new table_cell_1.TableCell(s);
                } else if (y === 1) {
                  continue;
                } else if (y > 1) {
                  const s = (_d = (_c = table.getCellAt(y, x)) === null || _c === void 0 ? void 0 : _c.content) !== null && _d !== void 0 ? _d : "";
                  newRow[y - 1] = new table_cell_1.TableCell(s);
                }
              }
              newRows[x] = new table_row_1.TableRow(newRow, "", "");
            } else if (x === 1) {
              const newRow = new Array(height - 1);
              for (let i = 0; i < height - 1; ++i) {
                newRow[i] = new table_cell_1.TableCell(" --- ");
              }
              newRows[x] = new table_row_1.TableRow(newRow, "", "");
              continue;
            } else if (x > 1) {
              const newRow = new Array(height - 1);
              for (let y = 0; y < height; ++y) {
                if (y === 0) {
                  const s = (_f = (_e = table.getCellAt(y, x - 1)) === null || _e === void 0 ? void 0 : _e.content) !== null && _f !== void 0 ? _f : "";
                  newRow[y] = new table_cell_1.TableCell(s);
                } else if (y === 1) {
                  continue;
                } else if (y > 1) {
                  const s = (_h = (_g = table.getCellAt(y, x - 1)) === null || _g === void 0 ? void 0 : _g.content) !== null && _h !== void 0 ? _h : "";
                  newRow[y - 1] = new table_cell_1.TableCell(s);
                }
              }
              newRows[x] = new table_row_1.TableRow(newRow, "", "");
            }
          }
          const newTable = new table_1.Table(newRows);
          const { table: formattedTable, focus: newFocus } = this.formatAndApply(options, range, lines, formulaLines, newTable, focus, true);
          this._moveToFocus(range.start.row, formattedTable, newFocus);
        });
      }
      /**
       * Sorts rows alphanumerically using the column at the current focus.
       * If all cells in the sorting column are numbers, the column is sorted
       * numerically.
       */
      sortRows(sortOrder, options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          const bodyRows = table.getRows().slice(2);
          const isNumber = (s) => /^\s*[-+]?((\d+(\.\d+)?)|(\d+\.)|(\.\d+))([eE][-+]?\d+)?\s*$/.test(s);
          const notAllNums = bodyRows.map((row) => {
            var _a;
            return (_a = row.getCellAt(focus.column)) === null || _a === void 0 ? void 0 : _a.content;
          }).some((cell) => cell !== void 0 && cell !== "" && !isNumber(cell));
          bodyRows.sort((rowA, rowB) => {
            const cellA = rowA.getCellAt(focus.column);
            const cellB = rowB.getCellAt(focus.column);
            if (cellA === void 0 || cellA.content === "") {
              if (cellB === void 0 || cellB.content === "") {
                return 0;
              }
              return -1;
            } else if (cellB === void 0 || cellB.content === "") {
              return 1;
            }
            const contentA = notAllNums ? cellA.content.replace(/[*~_$]/g, "") : parseFloat(cellA.content);
            const contentB = notAllNums ? cellB.content.replace(/[*~_$]/g, "") : parseFloat(cellB.content);
            if (contentA === contentB) {
              return 0;
            } else if (contentA === void 0) {
              return -1;
            } else if (contentB === void 0) {
              return 1;
            }
            return contentA < contentB ? -1 : 1;
          });
          if (sortOrder === SortOrder2.Descending) {
            bodyRows.reverse();
          }
          const allRows = table.getRows().slice(0, 2).concat(bodyRows);
          const newTable = new table_1.Table(allRows);
          const { table: formattedTable, focus: newFocus } = this.formatAndApply(options, range, lines, formulaLines, newTable, focus, true);
          this._moveToFocus(range.start.row, formattedTable, newFocus);
        });
      }
      /**
       * Inserts an empty column at the current focus.
       */
      insertColumn(options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          if (newFocus.row === 1) {
            newFocus = newFocus.setRow(0);
          }
          if (newFocus.column < 0) {
            newFocus = newFocus.setColumn(0);
          }
          const column = new Array(table.getHeight() - 1).fill(new table_cell_1.TableCell(""));
          const altered = (0, formatter_1.insertColumn)(table, newFocus.column, column, options);
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus);
        });
      }
      /**
       * Deletes a column at the current focus.
       */
      deleteColumn(options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          if (newFocus.row === 1) {
            newFocus = newFocus.setRow(0);
          }
          let altered = table;
          let moved = false;
          if (0 <= newFocus.column && newFocus.column <= altered.getHeaderWidth() - 1) {
            altered = (0, formatter_1.deleteColumn)(table, newFocus.column, options);
            moved = true;
            if (newFocus.column > altered.getHeaderWidth() - 1) {
              newFocus = newFocus.setColumn(altered.getHeaderWidth() - 1);
            }
          }
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus, moved);
        });
      }
      /**
       * Moves the focused column by the specified offset.
       *
       * @param offset - An offset the column is moved by.
       */
      moveColumn(offset, options) {
        this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          let newFocus = focus;
          let altered = table;
          if (0 <= newFocus.column && newFocus.column <= altered.getHeaderWidth() - 1) {
            const dest = Math.min(Math.max(newFocus.column + offset, 0), altered.getHeaderWidth() - 1);
            altered = (0, formatter_1.moveColumn)(altered, newFocus.column, dest);
            newFocus = newFocus.setColumn(dest);
          }
          this.formatAndApply(options, range, lines, formulaLines, altered, newFocus);
        });
      }
      /**
       * Formats all the tables in the text editor.
       */
      formatAll(options) {
        this._textEditor.transact(() => {
          const re = (0, exports._createIsTableRowRegex)(options.leftMarginChars);
          let pos = this._textEditor.getCursorPosition();
          let lines = [];
          let startRow = void 0;
          let lastRow = this._textEditor.getLastRow();
          for (let row = 0; row <= lastRow; row++) {
            const line = this._textEditor.getLine(row);
            if (this._textEditor.acceptsTableEdit(row) && re.test(line)) {
              lines.push(line);
              if (startRow === void 0) {
                startRow = row;
              }
            } else if (startRow !== void 0) {
              const endRow = row - 1;
              const range = new range_1.Range(new point_1.Point(startRow, 0), new point_1.Point(endRow, lines[lines.length - 1].length));
              const table = (0, parser_1.readTable)(lines, options);
              const focus = table.focusOfPosition(pos, startRow);
              let diff;
              if (focus !== void 0) {
                let newFocus = focus;
                const completed = (0, formatter_1.completeTable)(table, options);
                if (completed.delimiterInserted && newFocus.row > 0) {
                  newFocus = newFocus.setRow(newFocus.row + 1);
                }
                const formatted = (0, formatter_1.formatTable)(completed.table, options);
                newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, completed.table, formatted, false));
                const newLines = formatted.table.toLines();
                this._updateLines(range.start.row, range.end.row + 1, newLines, lines);
                diff = newLines.length - lines.length;
                pos = formatted.table.positionOfFocus(newFocus, startRow);
              } else {
                const completed = (0, formatter_1.completeTable)(table, options);
                const formatted = (0, formatter_1.formatTable)(completed.table, options);
                const newLines = formatted.table.toLines();
                this._updateLines(range.start.row, range.end.row + 1, newLines, lines);
                diff = newLines.length - lines.length;
                if (pos.row > endRow) {
                  pos = new point_1.Point(pos.row + diff, pos.column);
                }
              }
              lines = [];
              startRow = void 0;
              lastRow += diff;
              row += diff;
            }
          }
          if (startRow !== void 0) {
            const endRow = lastRow;
            const range = new range_1.Range(new point_1.Point(startRow, 0), new point_1.Point(endRow, lines[lines.length - 1].length));
            const table = (0, parser_1.readTable)(lines, options);
            const focus = table.focusOfPosition(pos, startRow);
            let newFocus = focus;
            const completed = (0, formatter_1.completeTable)(table, options);
            if (completed.delimiterInserted && newFocus.row > 0) {
              newFocus = newFocus.setRow(newFocus.row + 1);
            }
            const formatted = (0, formatter_1.formatTable)(completed.table, options);
            newFocus = newFocus.setOffset(
              // @ts-expect-error TODO
              (0, exports._computeNewOffset)(newFocus, completed.table, formatted, false)
            );
            const newLines = formatted.table.toLines();
            this._updateLines(range.start.row, range.end.row + 1, newLines, lines);
            pos = formatted.table.positionOfFocus(newFocus, startRow);
          }
          this._textEditor.setCursorPosition(pos);
        });
      }
      /**
       * Exports the table as a two dimensional string array
       */
      exportTable(withtHeaders, options) {
        return this.withCompletedTable(options, ({ range, lines, formulaLines, table, focus }) => {
          const bodyRows = table.getRows();
          if (bodyRows.length > 0 && !withtHeaders) {
            bodyRows.splice(0, 2);
          }
          return bodyRows.map((row) => row.getCells().map((cell) => cell.content));
        });
      }
      /**
       * Exports the table as a two dimensional string array
       */
      exportCSV(withtHeaders, options) {
        const r = this.exportTable(withtHeaders, options);
        return !r ? void 0 : r.map((row) => row.join("	")).join("\n");
      }
      /**
       * Finds a table, completes it, then does an operation with it.
       *
       * @param func - A function that does some operation on table information obtained by
       * {@link TableEditor#_findTable}.
       */
      withCompletedTable(options, func) {
        return this._withTable(options, (tableInfo) => {
          let newFocus = tableInfo.focus;
          const completed = (0, formatter_1.completeTable)(tableInfo.table, options);
          if (completed.delimiterInserted && newFocus.row > 0) {
            newFocus = newFocus.setRow(newFocus.row + 1);
          }
          const formatted = (0, formatter_1.formatTable)(completed.table, options);
          newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, completed.table, formatted, false));
          tableInfo.table = formatted.table;
          tableInfo.focus = newFocus;
          return func(tableInfo);
        });
      }
      /**
       * Formats the table and applies any changes based on the difference between
       * originalLines and the newTable. Should generally be the last function call
       * in a TableEditor function.
       */
      formatAndApply(options, range, originalLines, formulaLines, newTable, newFocus, moved = false) {
        const formatted = (0, formatter_1.formatTable)(newTable, options);
        newFocus = newFocus.setOffset((0, exports._computeNewOffset)(newFocus, newTable, formatted, moved));
        this._textEditor.transact(() => {
          this._updateLines(range.start.row, range.end.row + 1, formatted.table.toLines(), originalLines);
          if (moved) {
            this._selectFocus(range.start.row, formatted.table, newFocus);
          } else {
            this._moveToFocus(range.start.row, formatted.table, newFocus);
          }
        });
        this.resetSmartCursor();
        return {
          range,
          lines: originalLines,
          formulaLines,
          table: formatted.table,
          focus: newFocus
        };
      }
    };
    exports.TableEditor = TableEditor2;
  }
});

// node_modules/@tgrosinger/md-advanced-tables/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@tgrosinger/md-advanced-tables/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortOrder = exports.TableEditor = exports.optionsWithDefaults = exports.defaultOptions = exports.ITextEditor = exports.shortestEditScript = exports.applyEditScript = exports.Delete = exports.Insert = exports.moveColumn = exports.deleteColumn = exports.insertColumn = exports.moveRow = exports.deleteRow = exports.insertRow = exports.alterAlignment = exports.formatTable = exports.completeTable = exports.FormatType = exports.readTable = exports.Table = exports.TableRow = exports.TableCell = exports.HeaderAlignment = exports.DefaultAlignment = exports.Alignment = exports.Focus = exports.Range = exports.Point = void 0;
    var point_1 = require_point();
    Object.defineProperty(exports, "Point", { enumerable: true, get: function() {
      return point_1.Point;
    } });
    var range_1 = require_range();
    Object.defineProperty(exports, "Range", { enumerable: true, get: function() {
      return range_1.Range;
    } });
    var focus_1 = require_focus();
    Object.defineProperty(exports, "Focus", { enumerable: true, get: function() {
      return focus_1.Focus;
    } });
    var alignment_1 = require_alignment();
    Object.defineProperty(exports, "Alignment", { enumerable: true, get: function() {
      return alignment_1.Alignment;
    } });
    Object.defineProperty(exports, "DefaultAlignment", { enumerable: true, get: function() {
      return alignment_1.DefaultAlignment;
    } });
    Object.defineProperty(exports, "HeaderAlignment", { enumerable: true, get: function() {
      return alignment_1.HeaderAlignment;
    } });
    var table_cell_1 = require_table_cell();
    Object.defineProperty(exports, "TableCell", { enumerable: true, get: function() {
      return table_cell_1.TableCell;
    } });
    var table_row_1 = require_table_row();
    Object.defineProperty(exports, "TableRow", { enumerable: true, get: function() {
      return table_row_1.TableRow;
    } });
    var table_1 = require_table();
    Object.defineProperty(exports, "Table", { enumerable: true, get: function() {
      return table_1.Table;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports, "readTable", { enumerable: true, get: function() {
      return parser_1.readTable;
    } });
    var formatter_js_1 = require_formatter();
    Object.defineProperty(exports, "FormatType", { enumerable: true, get: function() {
      return formatter_js_1.FormatType;
    } });
    Object.defineProperty(exports, "completeTable", { enumerable: true, get: function() {
      return formatter_js_1.completeTable;
    } });
    Object.defineProperty(exports, "formatTable", { enumerable: true, get: function() {
      return formatter_js_1.formatTable;
    } });
    Object.defineProperty(exports, "alterAlignment", { enumerable: true, get: function() {
      return formatter_js_1.alterAlignment;
    } });
    Object.defineProperty(exports, "insertRow", { enumerable: true, get: function() {
      return formatter_js_1.insertRow;
    } });
    Object.defineProperty(exports, "deleteRow", { enumerable: true, get: function() {
      return formatter_js_1.deleteRow;
    } });
    Object.defineProperty(exports, "moveRow", { enumerable: true, get: function() {
      return formatter_js_1.moveRow;
    } });
    Object.defineProperty(exports, "insertColumn", { enumerable: true, get: function() {
      return formatter_js_1.insertColumn;
    } });
    Object.defineProperty(exports, "deleteColumn", { enumerable: true, get: function() {
      return formatter_js_1.deleteColumn;
    } });
    Object.defineProperty(exports, "moveColumn", { enumerable: true, get: function() {
      return formatter_js_1.moveColumn;
    } });
    var edit_script_1 = require_edit_script();
    Object.defineProperty(exports, "Insert", { enumerable: true, get: function() {
      return edit_script_1.Insert;
    } });
    Object.defineProperty(exports, "Delete", { enumerable: true, get: function() {
      return edit_script_1.Delete;
    } });
    Object.defineProperty(exports, "applyEditScript", { enumerable: true, get: function() {
      return edit_script_1.applyEditScript;
    } });
    Object.defineProperty(exports, "shortestEditScript", { enumerable: true, get: function() {
      return edit_script_1.shortestEditScript;
    } });
    var text_editor_1 = require_text_editor();
    Object.defineProperty(exports, "ITextEditor", { enumerable: true, get: function() {
      return text_editor_1.ITextEditor;
    } });
    var options_1 = require_options();
    Object.defineProperty(exports, "defaultOptions", { enumerable: true, get: function() {
      return options_1.defaultOptions;
    } });
    Object.defineProperty(exports, "optionsWithDefaults", { enumerable: true, get: function() {
      return options_1.optionsWithDefaults;
    } });
    var table_editor_1 = require_table_editor();
    Object.defineProperty(exports, "TableEditor", { enumerable: true, get: function() {
      return table_editor_1.TableEditor;
    } });
    Object.defineProperty(exports, "SortOrder", { enumerable: true, get: function() {
      return table_editor_1.SortOrder;
    } });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TableEditorPlugin
});
module.exports = __toCommonJS(main_exports);

// src/icons.ts
var import_obsidian = require("obsidian");
var icons = {
  spreadsheet: `
<svg version="1.1" viewBox="0 0 482.81 482.81" xmlns="http://www.w3.org/2000/svg">
  <path fill="currentColor" d="m457.58 25.464-432.83 0.42151c-13.658 0.013314-24.758 11.115-24.757 24.757l0.031024 347.45c7.4833e-4 8.3808 4.211 15.772 10.608 20.259 3.4533 2.4499 5.0716 3.2901 8.879 3.9022 1.7033 0.37333 3.4561 0.59471 5.2692 0.59294l432.84-0.42151c1.809-1e-3 3.5618-0.21823 5.2568-0.59294h1.2174v-0.37196c10.505-2.8727 18.279-12.397 18.278-23.788l-0.031-347.43c1e-3 -13.649-11.107-24.763-24.768-24.763zm3.5453 24.763v71.344h-163.31v-74.886h159.76c1.9641 0.0014 3.5467 1.5922 3.5467 3.5425zm-1.6737 350.37h-161.6v-67.207h163.31v64.268c1e-3 1.2572-0.70549 2.321-1.7033 2.9386zm-438.21-2.5171v-64.268h76.646v67.207h-74.942c-0.99784-0.61765-1.7033-1.6814-1.7033-2.9386zm255.28-155.18v69.688h-157.42v-69.688zm0 90.913v67.207h-157.42v-67.207zm-0.031-211.83h-157.42v-74.886h157.42zm0 21.226v77.826h-157.42v-77.826zm-178.64 77.826h-76.646v-77.826h76.646zm0.03102 21.862v69.688h-76.646v-69.688zm199.95 69.268v-69.697h163.31v69.697zm-0.031-91.552v-77.826h163.31v77.826z" stroke-width="1.3725"/>
</svg>`,
  alignLeft: `
<svg class="widget-icon" enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(-1 0 0 1 512 0)">
    <path d="m501.33 170.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
    <path d="m501.33 298.67h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
    <path d="m501.33 426.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
    <path d="m501.33 42.667h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
  </g>
</svg>`,
  alignCenter: `
<svg class="widget-icon" enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(-1 0 0 1 512 0)">
    <path d="m416 170.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
    <path d="m501.33 298.67h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
    <path d="m416 426.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
    <path d="m501.33 42.667h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
  </g>
</svg>`,
  alignRight: `
<svg class="widget-icon" enable-background="new 0 0 512 512" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m501.33 170.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
  <path d="m501.33 298.67h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
  <path d="m501.33 426.67h-320c-5.896 0-10.667 4.771-10.667 10.667v21.333c0 5.896 4.771 10.667 10.667 10.667h320c5.896 0 10.667-4.771 10.667-10.667v-21.333c0-5.896-4.771-10.667-10.667-10.667z"/>
  <path d="m501.33 42.667h-490.67c-5.896 0-10.667 4.771-10.667 10.666v21.333c0 5.896 4.771 10.667 10.667 10.667h490.67c5.896 0 10.667-4.771 10.667-10.667v-21.333c-1e-3 -5.895-4.772-10.666-10.668-10.666z"/>
</svg>`,
  deleteColumn: `
<svg class="widget-icon" enable-background="new 0 0 26 26" version="1.1" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg">
  <path d="m13.594 20.85v3.15h-10v-22h10v3.15c0.633-0.323 1.304-0.565 2-0.727v-3.423c0-0.551-0.448-1-1-1h-12c-0.55 0-1 0.449-1 1v24c0 0.551 0.449 1 1 1h12c0.552 0 1-0.449 1-1v-3.424c-0.696-0.161-1.367-0.403-2-0.726z"/>
  <path d="m17.594 6.188c-3.762 0-6.813 3.051-6.812 6.813-1e-3 3.761 3.05 6.812 6.812 6.812s6.813-3.051 6.813-6.813-3.052-6.812-6.813-6.812zm3.632 7.802-7.267 1e-3v-1.982h7.268l-1e-3 1.981z"/>
</svg>`,
  deleteRow: `
<svg class="widget-icon" enable-background="new 0 0 15.381 15.381" version="1.1" viewBox="0 0 15.381 15.381" xmlns="http://www.w3.org/2000/svg">
  <path d="M0,1.732v7.732h6.053c0-0.035-0.004-0.07-0.004-0.104c0-0.434,0.061-0.854,0.165-1.255H1.36V3.092    h12.662v2.192c0.546,0.396,1.01,0.897,1.359,1.477V1.732H0z"/>
  <path d="m11.196 5.28c-2.307 0-4.183 1.877-4.183 4.184 0 2.308 1.876 4.185 4.183 4.185 2.309 0 4.185-1.877 4.185-4.185 0-2.307-1.876-4.184-4.185-4.184zm0 7.233c-1.679 0-3.047-1.367-3.047-3.049 0-1.68 1.368-3.049 3.047-3.049 1.684 0 3.05 1.369 3.05 3.049 0 1.682-1.366 3.049-3.05 3.049z"/>
  <rect x="9.312" y="8.759" width="3.844" height="1.104"/>
</svg>`,
  insertColumn: `
<svg class="widget-icon" version="1.1" viewBox="-21 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m288 106.67c-3.9258 0-7.8516-1.4297-10.922-4.3125l-80-74.664c-4.8008-4.4805-6.3789-11.457-3.9688-17.559 2.4102-6.1016 8.3203-10.133 14.891-10.133h160c6.5703 0 12.48 4.0117 14.891 10.133 2.4102 6.125 0.83203 13.078-3.9688 17.559l-80 74.664c-3.0703 2.8828-6.9961 4.3125-10.922 4.3125zm-39.402-74.668 39.402 36.777 39.402-36.777z"/>
  <path d="m432 512h-53.332c-20.59 0-37.336-16.746-37.336-37.332v-330.67c0-20.586 16.746-37.332 37.336-37.332h53.332c20.586 0 37.332 16.746 37.332 37.332v330.67c0 20.586-16.746 37.332-37.332 37.332zm-53.332-373.33c-2.9453 0-5.3359 2.3867-5.3359 5.332v330.67c0 2.9414 2.3906 5.332 5.3359 5.332h53.332c2.9453 0 5.332-2.3906 5.332-5.332v-330.67c0-2.9453-2.3867-5.332-5.332-5.332z"/>
  <path d="m197.33 512h-160c-20.586 0-37.332-16.746-37.332-37.332v-330.67c0-20.586 16.746-37.332 37.332-37.332h160c20.59 0 37.336 16.746 37.336 37.332v330.67c0 20.586-16.746 37.332-37.336 37.332zm-160-373.33c-2.9414 0-5.332 2.3867-5.332 5.332v330.67c0 2.9414 2.3906 5.332 5.332 5.332h160c2.9453 0 5.3359-2.3906 5.3359-5.332v-330.67c0-2.9453-2.3906-5.332-5.3359-5.332z"/>
  <path d="m453.33 325.33h-96c-8.832 0-16-7.168-16-16s7.168-16 16-16h96c8.832 0 16 7.168 16 16s-7.168 16-16 16z"/>
  <path d="m218.67 325.33h-202.67c-8.832 0-16-7.168-16-16s7.168-16 16-16h202.67c8.832 0 16 7.168 16 16s-7.168 16-16 16z"/>
  <path d="m117.33 512c-8.832 0-16-7.168-16-16v-373.33c0-8.832 7.168-16 16-16s16 7.168 16 16v373.33c0 8.832-7.168 16-16 16z"/>
</svg>`,
  insertRow: `
<svg class="widget-icon" version="1.1" viewBox="0 -21 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m16 277.33c-1.9844 0-3.9688-0.36328-5.8672-1.1094-6.1211-2.4102-10.133-8.3203-10.133-14.891v-160c0-6.5703 4.0117-12.48 10.133-14.891 6.1445-2.4102 13.078-0.85156 17.559 3.9688l74.664 80c5.7617 6.1445 5.7617 15.68 0 21.824l-74.664 80c-3.0938 3.3281-7.3398 5.0977-11.691 5.0977zm16-135.4v78.805l36.777-39.402z"/>
  <path d="m474.67 128h-330.67c-20.586 0-37.332-16.746-37.332-37.332v-53.336c0-20.586 16.746-37.332 37.332-37.332h330.67c20.586 0 37.332 16.746 37.332 37.332v53.336c0 20.586-16.746 37.332-37.332 37.332zm-330.67-96c-2.9453 0-5.332 2.3906-5.332 5.332v53.336c0 2.9414 2.3867 5.332 5.332 5.332h330.67c2.9414 0 5.332-2.3906 5.332-5.332v-53.336c0-2.9414-2.3906-5.332-5.332-5.332z"/>
  <path d="m474.67 469.33h-330.67c-20.586 0-37.332-16.746-37.332-37.332v-160c0-20.586 16.746-37.332 37.332-37.332h330.67c20.586 0 37.332 16.746 37.332 37.332v160c0 20.586-16.746 37.332-37.332 37.332zm-330.67-202.66c-2.9453 0-5.332 2.3867-5.332 5.332v160c0 2.9453 2.3867 5.332 5.332 5.332h330.67c2.9414 0 5.332-2.3867 5.332-5.332v-160c0-2.9453-2.3906-5.332-5.332-5.332z"/>
  <path d="m309.33 128c-8.832 0-16-7.168-16-16v-96c0-8.832 7.168-16 16-16s16 7.168 16 16v96c0 8.832-7.168 16-16 16z"/>
  <path d="m309.33 469.33c-8.832 0-16-7.168-16-16v-202.66c0-8.832 7.168-16 16-16s16 7.168 16 16v202.66c0 8.832-7.168 16-16 16z"/>
  <path d="m496 368h-373.33c-8.832 0-16-7.168-16-16s7.168-16 16-16h373.33c8.832 0 16 7.168 16 16s-7.168 16-16 16z"/>
</svg>`,
  moveColumnLeft: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512.02 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m357.35 512.01h96c32.363 0 58.668-26.305 58.668-58.668v-394.66c0-32.363-26.305-58.668-58.668-58.668h-96c-32.363 0-58.664 26.305-58.664 58.668v394.66c0 32.363 26.301 58.668 58.664 58.668zm96-480c14.699 0 26.668 11.969 26.668 26.668v394.66c0 14.699-11.969 26.668-26.668 26.668h-96c-14.699 0-26.664-11.969-26.664-26.668v-394.66c0-14.699 11.965-26.668 26.664-26.668z"/>
  <path d="m16.016 272.01h224c8.832 0 16-7.168 16-16s-7.168-16-16-16h-224c-8.832 0-16 7.168-16 16s7.168 16 16 16z"/>
  <path d="m101.35 357.34c4.0976 0 8.1914-1.5547 11.309-4.6914 6.25-6.25 6.25-16.383 0-22.637l-74.027-74.023 74.027-74.027c6.25-6.25 6.25-16.387 0-22.637s-16.383-6.25-22.637 0l-85.332 85.336c-6.25 6.25-6.25 16.383 0 22.633l85.332 85.332c3.1367 3.1602 7.2344 4.7148 11.328 4.7148z"/>
</svg>`,
  moveColumnRight: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512.02 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m154.67 512.01h-96c-32.363 0-58.668-26.305-58.668-58.668v-394.66c0-32.363 26.305-58.668 58.668-58.668h96c32.363 0 58.664 26.305 58.664 58.668v394.66c0 32.363-26.301 58.668-58.664 58.668zm-96-480c-14.699 0-26.668 11.969-26.668 26.668v394.66c0 14.699 11.969 26.668 26.668 26.668h96c14.699 0 26.664-11.969 26.664-26.668v-394.66c0-14.699-11.965-26.668-26.664-26.668z"/>
  <path d="m496 272.01h-224c-8.832 0-16-7.168-16-16 0-8.832 7.168-16 16-16h224c8.832 0 16 7.168 16 16 0 8.832-7.168 16-16 16z"/>
  <path d="m410.67 357.34c-4.0977 0-8.1914-1.5547-11.309-4.6914-6.25-6.25-6.25-16.383 0-22.637l74.027-74.023-74.027-74.027c-6.25-6.25-6.25-16.387 0-22.637s16.383-6.25 22.637 0l85.332 85.336c6.25 6.25 6.25 16.383 0 22.633l-85.332 85.332c-3.1367 3.1602-7.2344 4.7148-11.328 4.7148z"/>
</svg>`,
  moveRowDown: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m453.33 213.33h-394.66c-32.363 0-58.668-26.301-58.668-58.664v-96c0-32.363 26.305-58.668 58.668-58.668h394.66c32.363 0 58.668 26.305 58.668 58.668v96c0 32.363-26.305 58.664-58.668 58.664zm-394.66-181.33c-14.699 0-26.668 11.969-26.668 26.668v96c0 14.699 11.969 26.664 26.668 26.664h394.66c14.699 0 26.668-11.965 26.668-26.664v-96c0-14.699-11.969-26.668-26.668-26.668z"/>
  <path d="m256 512c-8.832 0-16-7.168-16-16v-224c0-8.832 7.168-16 16-16s16 7.168 16 16v224c0 8.832-7.168 16-16 16z"/>
  <path d="m256 512c-4.0977 0-8.1914-1.5586-11.309-4.6914l-85.332-85.336c-6.25-6.25-6.25-16.383 0-22.633s16.383-6.25 22.637 0l74.023 74.027 74.027-74.027c6.25-6.25 16.387-6.25 22.637 0s6.25 16.383 0 22.633l-85.336 85.336c-3.1562 3.1328-7.25 4.6914-11.348 4.6914z"/>
</svg>`,
  moveRowUp: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m453.33 298.67h-394.66c-32.363 0-58.668 26.301-58.668 58.664v96c0 32.363 26.305 58.668 58.668 58.668h394.66c32.363 0 58.668-26.305 58.668-58.668v-96c0-32.363-26.305-58.664-58.668-58.664zm-394.66 181.33c-14.699 0-26.668-11.969-26.668-26.668v-96c0-14.699 11.969-26.664 26.668-26.664h394.66c14.699 0 26.668 11.965 26.668 26.664v96c0 14.699-11.969 26.668-26.668 26.668z"/>
  <path d="m256 0c-8.832 0-16 7.168-16 16v224c0 8.832 7.168 16 16 16s16-7.168 16-16v-224c0-8.832-7.168-16-16-16z"/>
  <path d="m256 0c-4.0977 0-8.1914 1.5586-11.309 4.6914l-85.332 85.336c-6.25 6.25-6.25 16.383 0 22.633s16.383 6.25 22.637 0l74.023-74.027 74.027 74.027c6.25 6.25 16.387 6.25 22.637 0s6.25-16.383 0-22.633l-85.336-85.336c-3.1562-3.1328-7.25-4.6914-11.348-4.6914z"/>
</svg>`,
  transpose: `
<svg class="widget-icon" version="1.1" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">
 <path d="m19 26h-5v-2h5a5.0055 5.0055 0 0 0 5-5v-5h2v5a7.0078 7.0078 0 0 1-7 7z"/>
 <path d="M8,30H4a2.0023,2.0023,0,0,1-2-2V14a2.0023,2.0023,0,0,1,2-2H8a2.0023,2.0023,0,0,1,2,2V28A2.0023,2.0023,0,0,1,8,30ZM4,14V28H8V14Z"/>
 <path d="M28,10H14a2.0023,2.0023,0,0,1-2-2V4a2.0023,2.0023,0,0,1,2-2H28a2.0023,2.0023,0,0,1,2,2V8A2.0023,2.0023,0,0,1,28,10ZM14,4V8H28V4Z"/>
</svg>`,
  sortAsc: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(1 0 0 -1 0 501.15)" stroke-width="1.3333">
    <path d="m353.6 74.486c-11.776 0-21.333 9.5573-21.333 21.333v298.67c0 11.776 9.5573 21.333 21.333 21.333s21.333-9.5573 21.333-21.333v-298.67c0-11.776-9.5573-21.333-21.333-21.333z"/>
    <path d="m353.6 74.486c-5.4636 0-10.922 2.0781-15.079 6.2552l-113.78 113.78c-8.3333 8.3333-8.3333 21.844 0 30.177 8.3333 8.3333 21.844 8.3333 30.183 0l98.697-98.703 98.703 98.703c8.3333 8.3333 21.849 8.3333 30.183 0 8.3333-8.3333 8.3333-21.844 0-30.177l-113.78-113.78c-4.2083-4.1771-9.6667-6.2552-15.131-6.2552z"/>
  </g>
  <path d="m166.04 210.11q-5.0971-13.492-9.5945-26.385-4.4974-13.192-9.2947-26.685h-94.146l-18.889 53.07h-30.283q11.993-32.981 22.487-60.865 10.494-28.184 20.388-53.369 10.194-25.186 20.089-47.973 9.8943-23.087 20.688-45.574h26.685q10.794 22.487 20.688 45.574 9.8943 22.787 19.789 47.973 10.194 25.186 20.688 53.369 10.494 27.884 22.487 60.865zm-27.284-77.056q-9.5945-26.085-19.189-50.371-9.2947-24.586-19.489-47.073-10.494 22.487-20.089 47.073-9.2947 24.286-18.589 50.371z"/>
  <path d="m173.24 325.25q-6.896 7.7955-16.191 18.889-8.9948 10.794-19.189 24.286-10.194 13.192-20.988 28.184-10.794 14.692-21.288 29.983-10.194 14.991-19.489 29.983-9.2947 14.991-16.79 28.484h116.93v24.886h-150.81v-19.489q6.2964-11.993 14.692-26.385 8.695-14.392 18.29-29.383 9.8943-14.991 20.388-30.283t20.688-29.383q10.494-14.092 20.088-26.385 9.8943-12.293 17.99-21.588h-106.74v-24.886h142.42z"/>
</svg>`,
  sortDesc: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <g transform="matrix(1 0 0 -1 0 501.15)" stroke-width="1.3333">
    <path d="m353.6 74.486c-11.776 0-21.333 9.5573-21.333 21.333v298.67c0 11.776 9.5573 21.333 21.333 21.333s21.333-9.5573 21.333-21.333v-298.67c0-11.776-9.5573-21.333-21.333-21.333z"/>
    <path d="m353.6 74.486c-5.4636 0-10.922 2.0781-15.079 6.2552l-113.78 113.78c-8.3333 8.3333-8.3333 21.844 0 30.177 8.3333 8.3333 21.844 8.3333 30.183 0l98.697-98.703 98.703 98.703c8.3333 8.3333 21.849 8.3333 30.183 0 8.3333-8.3333 8.3333-21.844 0-30.177l-113.78-113.78c-4.2083-4.1771-9.6667-6.2552-15.131-6.2552z"/>
  </g>
  <path d="m169.11 507.72q-5.0971-13.492-9.5945-26.385-4.4974-13.192-9.2947-26.685h-94.146l-18.889 53.07h-30.283q11.993-32.981 22.487-60.865 10.494-28.184 20.388-53.369 10.194-25.186 20.088-47.973 9.8943-23.087 20.688-45.574h26.685q10.794 22.487 20.688 45.574 9.8943 22.787 19.789 47.973 10.194 25.186 20.688 53.369 10.494 27.884 22.487 60.865zm-27.284-77.056q-9.5945-26.085-19.189-50.371-9.2947-24.586-19.489-47.073-10.494 22.487-20.089 47.073-9.2947 24.286-18.589 50.371z"/>
  <path d="m176.31 27.639q-6.896 7.7955-16.191 18.889-8.9948 10.794-19.189 24.286-10.194 13.192-20.988 28.184-10.794 14.692-21.288 29.983-10.194 14.991-19.489 29.983-9.2947 14.991-16.79 28.484h116.93v24.886h-150.81v-19.489q6.2964-11.993 14.692-26.385 8.695-14.392 18.29-29.383 9.8943-14.991 20.388-30.283 10.494-15.291 20.688-29.383 10.494-14.092 20.088-26.385 9.8943-12.293 17.99-21.588h-106.74v-24.886h142.42z"/>
</svg>`,
  formula: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m263.51 62.967c1.672-11.134 9.326-22.967 20.222-22.967 11.028 0 20 8.972 20 20h40c0-33.084-26.916-60-60-60-33.629 0-55.527 28.691-59.784 57.073l-12.862 86.927h-61.354v40h55.436l-39.22 265.07-0.116 0.937c-1.063 10.62-9.393 21.99-20.1 21.99-11.028 0-20-8.972-20-20h-40c0 33.084 26.916 60 60 60 33.661 0 56.771-29.141 59.848-57.496l40.023-270.5h60.129v-40h-54.211l11.989-81.033z"/>
  <polygon points="426.27 248 378.24 248 352.25 287.08 334.92 248 291.17 248 326 326.57 270.52 410 318.56 410 345.21 369.92 362.98 410 406.73 410 371.46 330.43"/>
</svg>`,
  help: `
<svg class="widget-icon" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg">
  <path d="m248.16 343.22c-14.639 0-26.491 12.2-26.491 26.84 0 14.291 11.503 26.84 26.491 26.84s26.84-12.548 26.84-26.84c0-14.64-12.199-26.84-26.84-26.84z"/>
  <path d="m252.69 140c-47.057 0-68.668 27.885-68.668 46.708 0 13.595 11.502 19.869 20.914 19.869 18.822 0 11.154-26.84 46.708-26.84 17.429 0 31.372 7.669 31.372 23.703 0 18.824-19.52 29.629-31.023 39.389-10.108 8.714-23.354 23.006-23.354 52.983 0 18.125 4.879 23.354 19.171 23.354 17.08 0 20.565-7.668 20.565-14.291 0-18.126 0.35-28.583 19.521-43.571 9.411-7.32 39.04-31.023 39.04-63.789s-29.629-57.515-74.246-57.515z"/>
  <path d="m256 0c-141.48 0-256 114.5-256 256v236c0 11.046 8.954 20 20 20h236c141.48 0 256-114.5 256-256 0-141.48-114.5-256-256-256zm0 472h-216v-216c0-119.38 96.607-216 216-216 119.38 0 216 96.607 216 216 0 119.38-96.607 216-216 216z"/>
</svg>`,
  csv: `
<svg class="widget-icon" version="1.1" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
 <path d="m4.9979 9v-8h14.502l3.5 3.5 2e-7 18.5h-19m14-22v5h5m-16 7h-2c-1 0-2 0.5-2 1.5v1.5s1e-8 0.5 0 1.5 1 1.5 2 1.5h2m6.25-6h-2.5c-1.5 0-2 0.5-2 1.5s0.5 1.5 2 1.5 2 0.5 2 1.5-0.5 1.5-2 1.5h-2.5m12.25-7v0.5c0 0.5-2.5 6.5-2.5 6.5h-0.5s-2.5-6-2.5-6.5v-0.5" fill="none" stroke="var(--text-muted)" stroke-width="1.5"/>
</svg>`,
  arrowenter: `
<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
  <path fill="currentColor" d="m4.64119 12.5 2.87283 2.7038c.30163.2839.31602.7586.03213 1.0602-.28389.3017-.75854.316-1.06017.0321l-4.25-4c-.15059-.1417-.23598-.3393-.23598-.5461s.08539-.4044.23598-.5462l4.25-3.99995c.30163-.28389.77628-.2695 1.06017.03213s.2695.77628-.03213 1.06017l-2.87284 2.70385h10.10882c.9665 0 1.75-.7835 1.75-1.75v-4.5c0-.41421.3358-.75.75-.75s.75.33579.75.75v4.5c0 1.7949-1.4551 3.25-3.25 3.25z"/>
</svg>`,
  arrowtab: `
<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
  <path fill="currentColor" d="m18.2071068 11.2928932-6.5-6.49999998c-.3905243-.39052429-1.0236893-.39052429-1.4142136 0-.36048394.36048396-.38821348.92771502-.0831886 1.32000622l.0831886.09420734 4.7931068 4.79289322h-11.086c-.51283584 0-.93550716.3860402-.99327227.8833789l-.00672773.1166211c0 .5128358.38604019.9355072.88337887.9932723l.11662113.0067277h11.086l-4.7931068 4.7928932c-.36048394.360484-.38821348.927715-.0831886 1.3200062l.0831886.0942074c.360484.3604839.927715.3882135 1.3200062.0831886l.0942074-.0831886 6.5-6.5c.3604839-.360484.3882135-.927715.0831886-1.3200062l-.0831886-.0942074-6.5-6.49999998zm2.7928932 7.2071068v-13c0-.55228475-.4477153-1-1-1s-1 .44771525-1 1v13c0 .5522847.4477153 1 1 1s1-.4477153 1-1z" fill="#212121"/>
</svg>`
};
var addIcons = () => {
  Object.keys(icons).forEach((key) => {
    if (key !== "help") {
      (0, import_obsidian.addIcon)(key, icons[key]);
    }
  });
};

// src/settings.ts
var import_md_advanced_tables = __toESM(require_lib2());
var defaultSettings = {
  formatType: import_md_advanced_tables.FormatType.NORMAL,
  showRibbonIcon: true,
  bindEnter: true,
  bindTab: true
};
var TableEditorPluginSettings = class {
  constructor(loadedData) {
    const allFields = { ...defaultSettings, ...loadedData };
    this.formatType = allFields.formatType;
    this.showRibbonIcon = allFields.showRibbonIcon;
    this.bindEnter = allFields.bindEnter;
    this.bindTab = allFields.bindTab;
  }
  asOptions() {
    return (0, import_md_advanced_tables.optionsWithDefaults)({ formatType: this.formatType });
  }
};

// src/obsidian-text-editor.ts
var import_md_advanced_tables2 = __toESM(require_lib2());
var ObsidianTextEditor = class {
  constructor(app, file, editor) {
    this.getCursorPosition = () => {
      const position = this.editor.getCursor();
      return new import_md_advanced_tables2.Point(position.line, position.ch);
    };
    this.setCursorPosition = (pos) => {
      this.editor.setCursor({ line: pos.row, ch: pos.column });
    };
    this.setSelectionRange = (range) => {
      this.editor.setSelection(
        { line: range.start.row, ch: range.start.column },
        { line: range.end.row, ch: range.end.column }
      );
    };
    this.getLastRow = () => this.editor.lastLine();
    this.acceptsTableEdit = (row) => {
      const cache = this.app.metadataCache.getFileCache(this.file);
      if (!cache.sections) {
        return true;
      }
      const table = cache.sections.find(
        (section) => section.position.start.line <= row && section.position.end.line >= row && section.type !== "code" && section.type !== "math"
      );
      if (table === void 0) {
        return false;
      }
      const preceedingLineIndex = table.position.start.line;
      if (preceedingLineIndex >= 0) {
        const preceedingLine = this.getLine(preceedingLineIndex);
        if (preceedingLine === "-tx-") {
          return false;
        }
      }
      return true;
    };
    this.getLine = (row) => this.editor.getLine(row);
    this.insertLine = (row, line) => {
      if (row > this.getLastRow()) {
        this.editor.replaceRange("\n" + line, { line: row, ch: 0 });
      } else {
        this.editor.replaceRange(line + "\n", { line: row, ch: 0 });
      }
    };
    this.deleteLine = (row) => {
      if (row === this.getLastRow()) {
        const rowContents = this.getLine(row);
        this.editor.replaceRange(
          "",
          { line: row, ch: 0 },
          { line: row, ch: rowContents.length }
        );
      } else {
        this.editor.replaceRange(
          "",
          { line: row, ch: 0 },
          { line: row + 1, ch: 0 }
        );
      }
    };
    this.replaceLines = (startRow, endRow, lines) => {
      const realEndRow = endRow - 1;
      const endRowContents = this.editor.getLine(realEndRow);
      const endRowFinalIndex = endRowContents.length;
      this.editor.replaceRange(
        lines.join("\n"),
        { line: startRow, ch: 0 },
        { line: realEndRow, ch: endRowFinalIndex }
      );
    };
    this.transact = (func) => {
      func();
    };
    this.app = app;
    this.file = file;
    this.editor = editor;
  }
};

// src/table-editor.ts
var import_md_advanced_tables3 = __toESM(require_lib2());
var import_obsidian2 = require("obsidian");
var TableEditor = class {
  constructor(app, file, editor, settings) {
    this.cursorIsInTableFormula = () => this.mte.cursorIsInTableFormula(this.settings.asOptions());
    this.cursorIsInTable = () => this.mte.cursorIsInTable(this.settings.asOptions());
    this.nextCell = () => {
      this.mte.nextCell(this.settings.asOptions());
    };
    this.previousCell = () => {
      this.mte.previousCell(this.settings.asOptions());
    };
    this.nextRow = () => {
      this.mte.nextRow(this.settings.asOptions());
    };
    this.formatTable = () => {
      this.mte.format(this.settings.asOptions());
    };
    this.formatAllTables = () => {
      this.mte.formatAll(this.settings.asOptions());
    };
    this.insertColumn = () => {
      this.mte.insertColumn(this.settings.asOptions());
    };
    this.insertRow = () => {
      this.mte.insertRow(this.settings.asOptions());
    };
    this.leftAlignColumn = () => {
      this.mte.alignColumn(import_md_advanced_tables3.Alignment.LEFT, this.settings.asOptions());
    };
    this.centerAlignColumn = () => {
      this.mte.alignColumn(import_md_advanced_tables3.Alignment.CENTER, this.settings.asOptions());
    };
    this.rightAlignColumn = () => {
      this.mte.alignColumn(import_md_advanced_tables3.Alignment.RIGHT, this.settings.asOptions());
    };
    this.moveColumnLeft = () => {
      this.mte.moveColumn(-1, this.settings.asOptions());
    };
    this.moveColumnRight = () => {
      this.mte.moveColumn(1, this.settings.asOptions());
    };
    this.moveRowUp = () => {
      this.mte.moveRow(-1, this.settings.asOptions());
    };
    this.moveRowDown = () => {
      this.mte.moveRow(1, this.settings.asOptions());
    };
    this.deleteColumn = () => {
      this.mte.deleteColumn(this.settings.asOptions());
    };
    this.deleteRow = () => {
      this.mte.deleteRow(this.settings.asOptions());
    };
    this.sortRowsAsc = () => {
      this.mte.sortRows(import_md_advanced_tables3.SortOrder.Ascending, this.settings.asOptions());
    };
    this.sortRowsDesc = () => {
      this.mte.sortRows(import_md_advanced_tables3.SortOrder.Descending, this.settings.asOptions());
    };
    this.transpose = () => {
      this.mte.transpose(this.settings.asOptions());
    };
    this.escape = () => {
      this.mte.escape(this.settings.asOptions());
    };
    this.evaluateFormulas = () => {
      const err = this.mte.evaluateFormulas(this.settings.asOptions());
      if (err) {
        new import_obsidian2.Notice(err.message);
      }
    };
    this.exportCSVModal = () => {
      new CSVModal(this.app, this.mte, this.settings).open();
    };
    this.app = app;
    this.settings = settings;
    const ote = new ObsidianTextEditor(app, file, editor);
    this.mte = new import_md_advanced_tables3.TableEditor(ote);
  }
};
var CSVModal = class extends import_obsidian2.Modal {
  constructor(app, mte, settings) {
    super(app);
    this.mte = mte;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    const div = contentEl.createDiv({
      cls: "advanced-tables-csv-export"
    });
    const ta = div.createEl("textarea", {
      attr: {
        readonly: true
      }
    });
    ta.value = this.mte.exportCSV(true, this.settings.asOptions());
    ta.onClickEvent(() => ta.select());
    const lb = div.createEl("label");
    const cb = lb.createEl("input", {
      type: "checkbox",
      attr: {
        checked: true
      }
    });
    lb.createSpan().setText("Include table headers");
    cb.onClickEvent(() => {
      ta.value = this.mte.exportCSV(cb.checked, this.settings.asOptions());
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/table-controls-view.ts
var import_obsidian3 = require("obsidian");
var TableControlsViewType = "advanced-tables-toolbar";
var TableControlsView = class extends import_obsidian3.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.draw = () => {
      const container = this.containerEl.children[1];
      const rootEl = document.createElement("div");
      rootEl.addClass("advanced-tables-buttons");
      rootEl.createDiv().createSpan({ cls: "title" }).setText("Advanced Tables");
      const navHeader = rootEl.createDiv({ cls: "nav-header" });
      const rowOneBtns = navHeader.createDiv({ cls: "nav-buttons-container" });
      rowOneBtns.createSpan({ cls: "advanced-tables-row-label" }).setText("Align:");
      this.drawBtn(
        rowOneBtns,
        "alignLeft",
        "left align column",
        (te) => te.leftAlignColumn()
      );
      this.drawBtn(
        rowOneBtns,
        "alignCenter",
        "center align column",
        (te) => te.centerAlignColumn()
      );
      this.drawBtn(
        rowOneBtns,
        "alignRight",
        "right align column",
        (te) => te.rightAlignColumn()
      );
      const rowTwoBtns = navHeader.createDiv({ cls: "nav-buttons-container" });
      rowTwoBtns.createSpan({ cls: "advanced-tables-row-label" }).setText("Move:");
      this.drawBtn(
        rowTwoBtns,
        "moveRowDown",
        "move row down",
        (te) => te.moveRowDown()
      );
      this.drawBtn(
        rowTwoBtns,
        "moveRowUp",
        "move row up",
        (te) => te.moveRowUp()
      );
      this.drawBtn(
        rowTwoBtns,
        "moveColumnRight",
        "move column right",
        (te) => te.moveColumnRight()
      );
      this.drawBtn(
        rowTwoBtns,
        "moveColumnLeft",
        "move column left",
        (te) => te.moveColumnLeft()
      );
      this.drawBtn(
        rowTwoBtns,
        "transpose",
        "transpose",
        (te) => te.transpose()
      );
      const rowThreeBtns = navHeader.createDiv({ cls: "nav-buttons-container" });
      rowThreeBtns.createSpan({ cls: "advanced-tables-row-label" }).setText("Edit:");
      this.drawBtn(
        rowThreeBtns,
        "insertRow",
        "insert row above",
        (te) => te.insertRow()
      );
      this.drawBtn(
        rowThreeBtns,
        "insertColumn",
        "insert column left",
        (te) => te.insertColumn()
      );
      this.drawBtn(
        rowThreeBtns,
        "deleteRow",
        "delete row",
        (te) => te.deleteRow()
      );
      this.drawBtn(
        rowThreeBtns,
        "deleteColumn",
        "delete column",
        (te) => te.deleteColumn()
      );
      const rowFourBtns = navHeader.createDiv({ cls: "nav-buttons-container" });
      rowFourBtns.createSpan({ cls: "advanced-tables-row-label" }).setText("Sort/F:");
      this.drawBtn(
        rowFourBtns,
        "sortAsc",
        "sort by column ascending",
        (te) => te.sortRowsAsc()
      );
      this.drawBtn(
        rowFourBtns,
        "sortDesc",
        "sort by column descending",
        (te) => te.sortRowsDesc()
      );
      this.drawBtn(
        rowFourBtns,
        "formula",
        "evaluate formulas",
        (te) => te.evaluateFormulas()
      );
      const rowFiveBtns = navHeader.createDiv({ cls: "nav-buttons-container" });
      rowFiveBtns.createSpan({ cls: "advanced-tables-row-label" }).setText("Misc:");
      this.drawBtn(
        rowFiveBtns,
        "csv",
        "export as csv",
        (te) => te.exportCSVModal()
      );
      this.drawBtn(
        rowFiveBtns,
        "help",
        "help",
        () => window.open(
          "https://github.com/tgrosinger/advanced-tables-obsidian/blob/main/docs/help.md"
        )
      );
      container.empty();
      container.appendChild(rootEl);
    };
    this.drawBtn = (parent, iconName, title, fn) => {
      const cursorCheck = (te) => {
        if (title === "evaluate formulas") {
          return te.cursorIsInTable() || te.cursorIsInTableFormula();
        }
        return te.cursorIsInTable();
      };
      const button = parent.createDiv({ cls: "advanced-tables-button nav-action-button", title });
      button.onClickEvent(() => this.withTE(fn, cursorCheck));
      button.appendChild(Element(icons[iconName]));
    };
    this.withTE = (fn, cursorCheck, alertOnNoTable = true) => {
      let editor;
      const leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf.view instanceof import_obsidian3.MarkdownView) {
        editor = leaf.view.editor;
      } else {
        console.warn("Advanced Tables: Unable to determine current editor.");
        return;
      }
      const te = new TableEditor(this.app, leaf.view.file, editor, this.settings);
      if (!cursorCheck(te)) {
        if (alertOnNoTable) {
          new import_obsidian3.Notice("Advanced Tables: Cursor must be in a table.");
        }
        return;
      }
      fn(te);
    };
    this.settings = settings;
  }
  getViewType() {
    return TableControlsViewType;
  }
  getDisplayText() {
    return "Advanced Tables";
  }
  getIcon() {
    return "spreadsheet";
  }
  load() {
    super.load();
    this.draw();
  }
};
var Element = (svgText) => {
  const parser = new DOMParser();
  return parser.parseFromString(svgText, "text/xml").documentElement;
};

// src/main.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_md_advanced_tables4 = __toESM(require_lib2());
var import_obsidian4 = require("obsidian");
var TableEditorPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    // makeEditorExtension is used to bind Tab and Enter in the new CM6 Live Preview editor.
    this.makeEditorExtension = () => {
      const keymaps = [];
      if (this.settings.bindEnter) {
        keymaps.push({
          key: "Enter",
          run: () => this.newPerformTableActionCM6((te) => te.nextRow())(),
          preventDefault: true
        });
      }
      if (this.settings.bindTab) {
        keymaps.push({
          key: "Tab",
          run: () => this.newPerformTableActionCM6((te) => te.nextCell())(),
          shift: () => this.newPerformTableActionCM6(
            (te) => te.previousCell()
          )(),
          preventDefault: true
        });
      }
      return import_state.Prec.highest(import_view.keymap.of(keymaps));
    };
    this.newPerformTableActionCM6 = (fn) => () => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (view) {
        const currentMode = view.currentMode;
        if ("sourceMode" in currentMode && !currentMode.sourceMode) {
          return false;
        }
        const te = new TableEditor(
          this.app,
          view.file,
          view.editor,
          this.settings
        );
        if (te.cursorIsInTable()) {
          fn(te);
          return true;
        }
      }
      return false;
    };
    this.newPerformTableAction = (fn, alertOnNoTable = true) => (checking, editor, view) => {
      const te = new TableEditor(this.app, view.file, editor, this.settings);
      if (checking) {
        return te.cursorIsInTable();
      }
      fn(te);
    };
    // handleKeyDown is used to bind the tab and enter keys in the legacy CM5 editor.
    this.handleKeyDown = (cm, event) => {
      if (["Tab", "Enter"].contains(event.key)) {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        const editor = view ? view.editor : null;
        const action = this.newPerformTableAction((te) => {
          switch (event.key) {
            case "Tab":
              if (!this.settings.bindTab) {
                return;
              }
              if (event.shiftKey) {
                te.previousCell();
              } else {
                te.nextCell();
              }
              break;
            case "Enter":
              if (!this.settings.bindEnter) {
                return;
              }
              if (event.shiftKey) {
                te.escape();
              } else if (event.ctrlKey || event.metaKey || event.altKey) {
                return;
              } else {
                te.nextRow();
              }
              break;
          }
          event.preventDefault();
        }, false);
        if (action(true, editor, view)) {
          action(false, editor, view);
        }
      }
    };
    this.toggleTableControlsView = async () => {
      const existing = this.app.workspace.getLeavesOfType(TableControlsViewType);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: TableControlsViewType,
        active: true
      });
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(TableControlsViewType)[0]
      );
    };
    this.isMobile = () => this.app.isMobile;
  }
  async onload() {
    console.log("loading markdown-table-editor plugin");
    await this.loadSettings();
    this.registerView(
      TableControlsViewType,
      (leaf) => new TableControlsView(leaf, this.settings)
    );
    addIcons();
    if (this.settings.showRibbonIcon) {
      this.addRibbonIcon("spreadsheet", "Advanced Tables Toolbar", () => {
        this.toggleTableControlsView();
      });
    }
    this.registerEditorExtension(this.makeEditorExtension());
    this.addCommand({
      id: "next-row",
      name: "Go to next row",
      icon: "arrowenter",
      editorCheckCallback: this.newPerformTableAction((te) => {
        if (this.settings.bindEnter && !this.isMobile) {
          new import_obsidian4.Notice(
            "Advanced Tables: Next row also bound to enter. Possibly producing double actions. See Advanced Tables settings."
          );
        }
        te.nextRow();
      })
    });
    this.addCommand({
      id: "next-cell",
      name: "Go to next cell",
      icon: "arrowtab",
      editorCheckCallback: this.newPerformTableAction((te) => {
        if (this.settings.bindTab && !this.isMobile) {
          new import_obsidian4.Notice(
            "Advanced Tables: Next cell also bound to tab. Possibly producing double actions. See Advanced Tables settings."
          );
        }
        te.nextCell();
      })
    });
    this.addCommand({
      id: "previous-cell",
      name: "Go to previous cell",
      editorCheckCallback: this.newPerformTableAction((te) => {
        if (this.settings.bindTab && !this.isMobile) {
          new import_obsidian4.Notice(
            "Advanced Tables: Previous cell also bound to shift+tab. Possibly producing double actions. See Advanced Tables settings."
          );
        }
        te.previousCell();
      })
    });
    this.addCommand({
      id: "format-table",
      name: "Format table at the cursor",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.formatTable();
      })
    });
    this.addCommand({
      id: "format-all-tables",
      name: "Format all tables in this file",
      editorCallback: (editor, view) => {
        const te = new TableEditor(this.app, view.file, editor, this.settings);
        te.formatAllTables();
      }
    });
    this.addCommand({
      id: "insert-column",
      name: "Insert column before current",
      icon: "insertColumn",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.insertColumn();
      })
    });
    this.addCommand({
      id: "insert-row",
      name: "Insert row before current",
      icon: "insertRow",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.insertRow();
      })
    });
    this.addCommand({
      id: "escape-table",
      name: "Move cursor out of table",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.escape();
      })
    });
    this.addCommand({
      id: "left-align-column",
      name: "Left align column",
      icon: "alignLeft",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.leftAlignColumn();
      })
    });
    this.addCommand({
      id: "center-align-column",
      name: "Center align column",
      icon: "alignCenter",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.centerAlignColumn();
      })
    });
    this.addCommand({
      id: "right-align-column",
      name: "Right align column",
      icon: "alignRight",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.rightAlignColumn();
      })
    });
    this.addCommand({
      id: "move-column-left",
      name: "Move column left",
      icon: "moveColumnLeft",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.moveColumnLeft();
      })
    });
    this.addCommand({
      id: "move-column-right",
      name: "Move column right",
      icon: "moveColumnRight",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.moveColumnRight();
      })
    });
    this.addCommand({
      id: "move-row-up",
      name: "Move row up",
      icon: "moveRowUp",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.moveRowUp();
      })
    });
    this.addCommand({
      id: "move-row-down",
      name: "Move row down",
      icon: "moveRowDown",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.moveRowDown();
      })
    });
    this.addCommand({
      id: "delete-column",
      name: "Delete column",
      icon: "deleteColumn",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.deleteColumn();
      })
    });
    this.addCommand({
      id: "delete-row",
      name: "Delete row",
      icon: "deleteRow",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.deleteRow();
      })
    });
    this.addCommand({
      id: "sort-rows-ascending",
      name: "Sort rows ascending",
      icon: "sortAsc",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.sortRowsAsc();
      })
    });
    this.addCommand({
      id: "sort-rows-descending",
      name: "Sort rows descending",
      icon: "sortDesc",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.sortRowsDesc();
      })
    });
    this.addCommand({
      id: "transpose",
      name: "Transpose",
      icon: "transpose",
      editorCheckCallback: this.newPerformTableAction((te) => {
        te.transpose();
      })
    });
    this.addCommand({
      id: "evaluate-formulas",
      name: "Evaluate table formulas",
      icon: "formula",
      editorCheckCallback: (checking, editor, view) => {
        const te = new TableEditor(this.app, view.file, editor, this.settings);
        if (checking) {
          return te.cursorIsInTable() || te.cursorIsInTableFormula();
        }
        te.evaluateFormulas();
      }
    });
    this.addCommand({
      id: "table-control-bar",
      name: "Open table controls toolbar",
      hotkeys: [
        {
          modifiers: ["Mod", "Shift"],
          key: "d"
        }
      ],
      callback: () => {
        this.toggleTableControlsView();
      }
    });
    this.addSettingTab(new TableEditorSettingsTab(this.app, this));
  }
  async loadSettings() {
    const settingsOptions = Object.assign(
      defaultSettings,
      await this.loadData()
    );
    this.settings = new TableEditorPluginSettings(settingsOptions);
    this.saveData(this.settings);
  }
};
var TableEditorSettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Advanced Tables Plugin - Settings" });
    new import_obsidian4.Setting(containerEl).setName("Bind enter to table navigation").setDesc(
      'Requires restart of Obsidian. If enabled, when the cursor is in a table, enter advances to the next row. Disabling this can help avoid conflicting with tag or CJK autocompletion. If disabling, bind "Go to ..." in the Obsidian Hotkeys settings.'
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.bindEnter).onChange((value) => {
        this.plugin.settings.bindEnter = value;
        this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Bind tab to table navigation").setDesc(
      'Requires restart of Obsidian. If enabled, when the cursor is in a table, tab/shift+tab navigate between cells. Disabling this can help avoid conflicting with tag or CJK autocompletion. If disabling, bind "Go to ..." in the Obsidian Hotkeys settings.'
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.bindTab).onChange((value) => {
        this.plugin.settings.bindTab = value;
        this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Pad cell width using spaces").setDesc(
      "If enabled, table cells will have spaces added to match the width of the longest cell in the column."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.formatType === import_md_advanced_tables4.FormatType.NORMAL).onChange((value) => {
        this.plugin.settings.formatType = value ? import_md_advanced_tables4.FormatType.NORMAL : import_md_advanced_tables4.FormatType.WEAK;
        this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Show icon in sidebar").setDesc(
      "If enabled, a button which opens the table controls toolbar will be added to the Obsidian sidebar. The toolbar can also be opened with a Hotkey. Changes only take effect on reload."
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showRibbonIcon).onChange((value) => {
        this.plugin.settings.showRibbonIcon = value;
        this.plugin.saveData(this.plugin.settings);
        this.display();
      })
    );
    const div = containerEl.createEl("div", {
      cls: "advanced-tables-donation"
    });
    const donateText = document.createElement("p");
    donateText.appendText(
      "If this plugin adds value for you and you would like to help support continued development, please use the buttons below:"
    );
    div.appendChild(donateText);
    const parser = new DOMParser();
    div.appendChild(
      createDonateButton(
        "https://paypal.me/tgrosinger",
        parser.parseFromString(paypal, "text/xml").documentElement
      )
    );
    div.appendChild(
      createDonateButton(
        "https://www.buymeacoffee.com/tgrosinger",
        parser.parseFromString(buyMeACoffee, "text/xml").documentElement
      )
    );
  }
};
var createDonateButton = (link, img) => {
  const a = document.createElement("a");
  a.setAttribute("href", link);
  a.addClass("advanced-tables-donate-button");
  a.appendChild(img);
  return a;
};
var buyMeACoffee = `
<svg width="150" height="42" viewBox="0 0 260 73" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0 11.68C0 5.22932 5.22931 0 11.68 0H248.2C254.651 0 259.88 5.22931 259.88 11.68V61.32C259.88 67.7707 254.651 73 248.2 73H11.68C5.22931 73 0 67.7707 0 61.32V11.68Z" fill="#FFDD00"/>
<path d="M52.2566 24.0078L52.2246 23.9889L52.1504 23.9663C52.1802 23.9915 52.2176 24.0061 52.2566 24.0078Z" fill="#0D0C22"/>
<path d="M52.7248 27.3457L52.6895 27.3556L52.7248 27.3457Z" fill="#0D0C22"/>
<path d="M52.2701 24.0024C52.266 24.0019 52.2619 24.0009 52.258 23.9995C52.2578 24.0022 52.2578 24.0049 52.258 24.0076C52.2624 24.007 52.2666 24.0052 52.2701 24.0024Z" fill="#0D0C22"/>
<path d="M52.2578 24.0094H52.2643V24.0054L52.2578 24.0094Z" fill="#0D0C22"/>
<path d="M52.6973 27.3394L52.7513 27.3086L52.7714 27.2973L52.7897 27.2778C52.7554 27.2926 52.7241 27.3135 52.6973 27.3394Z" fill="#0D0C22"/>
<path d="M52.3484 24.0812L52.2956 24.031L52.2598 24.0115C52.279 24.0454 52.3108 24.0705 52.3484 24.0812Z" fill="#0D0C22"/>
<path d="M39.0684 56.469C39.0262 56.4872 38.9893 56.5158 38.9609 56.552L38.9943 56.5306C39.0169 56.5098 39.0489 56.4853 39.0684 56.469Z" fill="#0D0C22"/>
<path d="M46.7802 54.9518C46.7802 54.9041 46.7569 54.9129 46.7626 55.0826C46.7626 55.0687 46.7683 55.0549 46.7708 55.0417C46.7739 55.0115 46.7764 54.982 46.7802 54.9518Z" fill="#0D0C22"/>
<path d="M45.9844 56.469C45.9422 56.4872 45.9053 56.5158 45.877 56.552L45.9103 56.5306C45.9329 56.5098 45.9649 56.4853 45.9844 56.469Z" fill="#0D0C22"/>
<path d="M33.6307 56.8301C33.5987 56.8023 33.5595 56.784 33.5176 56.7773C33.5515 56.7937 33.5855 56.81 33.6081 56.8226L33.6307 56.8301Z" fill="#0D0C22"/>
<path d="M32.4118 55.6598C32.4068 55.6103 32.3916 55.5624 32.3672 55.519C32.3845 55.5642 32.399 55.6104 32.4106 55.6573L32.4118 55.6598Z" fill="#0D0C22"/>
<path d="M40.623 34.7221C38.9449 35.4405 37.0404 36.2551 34.5722 36.2551C33.5397 36.2531 32.5122 36.1114 31.5176 35.834L33.2247 53.3605C33.2851 54.093 33.6188 54.7761 34.1595 55.2739C34.7003 55.7718 35.4085 56.0482 36.1435 56.048C36.1435 56.048 38.564 56.1737 39.3716 56.1737C40.2409 56.1737 42.8474 56.048 42.8474 56.048C43.5823 56.048 44.2904 55.7716 44.831 55.2737C45.3716 54.7759 45.7052 54.0929 45.7656 53.3605L47.594 33.993C46.7769 33.714 45.9523 33.5286 45.0227 33.5286C43.415 33.5279 42.1196 34.0817 40.623 34.7221Z" fill="white"/>
<path d="M26.2344 27.2449L26.2633 27.2719L26.2821 27.2832C26.2676 27.2688 26.2516 27.2559 26.2344 27.2449Z" fill="#0D0C22"/>
<path d="M55.4906 25.6274L55.2336 24.3307C55.0029 23.1673 54.4793 22.068 53.2851 21.6475C52.9024 21.513 52.468 21.4552 52.1745 21.1768C51.881 20.8983 51.7943 20.4659 51.7264 20.0649C51.6007 19.3289 51.4825 18.5923 51.3537 17.8575C51.2424 17.2259 51.1544 16.5163 50.8647 15.9368C50.4876 15.1586 49.705 14.7036 48.9269 14.4025C48.5282 14.2537 48.1213 14.1278 47.7082 14.0254C45.7642 13.5125 43.7202 13.324 41.7202 13.2165C39.3197 13.084 36.9128 13.1239 34.518 13.3359C32.7355 13.4981 30.8581 13.6942 29.1642 14.3108C28.5451 14.5364 27.9071 14.8073 27.4364 15.2856C26.8587 15.8733 26.6702 16.7821 27.0919 17.515C27.3917 18.0354 27.8996 18.4031 28.4382 18.6463C29.1398 18.9597 29.8726 19.1982 30.6242 19.3578C32.7172 19.8204 34.885 20.0021 37.0233 20.0794C39.3932 20.175 41.767 20.0975 44.1256 19.8474C44.7089 19.7833 45.2911 19.7064 45.8723 19.6168C46.5568 19.5118 46.9961 18.6168 46.7943 17.9933C46.553 17.2479 45.9044 16.9587 45.1709 17.0712C45.0628 17.0882 44.9553 17.1039 44.8472 17.1196L44.7692 17.131C44.5208 17.1624 44.2723 17.1917 44.0238 17.219C43.5105 17.2743 42.9959 17.3195 42.4801 17.3547C41.3249 17.4352 40.1665 17.4722 39.0088 17.4741C37.8712 17.4741 36.7329 17.4421 35.5978 17.3673C35.0799 17.3333 34.5632 17.2902 34.0478 17.2378C33.8134 17.2133 33.5796 17.1875 33.3458 17.1586L33.1233 17.1303L33.0749 17.1234L32.8442 17.0901C32.3728 17.0191 31.9014 16.9374 31.435 16.8387C31.388 16.8283 31.3459 16.8021 31.3157 16.7645C31.2856 16.7269 31.2691 16.6801 31.2691 16.6319C31.2691 16.5837 31.2856 16.5369 31.3157 16.4993C31.3459 16.4617 31.388 16.4356 31.435 16.4251H31.4438C31.848 16.339 32.2553 16.2655 32.6638 16.2014C32.8 16.18 32.9366 16.159 33.0736 16.1385H33.0774C33.3332 16.1215 33.5903 16.0757 33.8448 16.0455C36.0595 15.8151 38.2874 15.7366 40.5128 15.8104C41.5933 15.8419 42.6731 15.9053 43.7485 16.0147C43.9798 16.0386 44.2098 16.0637 44.4399 16.092C44.5279 16.1027 44.6165 16.1153 44.7051 16.1259L44.8836 16.1517C45.404 16.2292 45.9217 16.3233 46.4367 16.4339C47.1997 16.5999 48.1796 16.6539 48.519 17.4898C48.6271 17.7551 48.6761 18.0499 48.7359 18.3283L48.8119 18.6834C48.8139 18.6898 48.8154 18.6963 48.8163 18.7029C48.9961 19.5409 49.176 20.379 49.3562 21.217C49.3694 21.2789 49.3697 21.3429 49.3571 21.4049C49.3445 21.4669 49.3193 21.5257 49.2829 21.5776C49.2466 21.6294 49.2 21.6732 49.146 21.7062C49.092 21.7392 49.0317 21.7608 48.969 21.7695H48.964L48.854 21.7846L48.7453 21.799C48.4009 21.8439 48.056 21.8858 47.7107 21.9247C47.0307 22.0022 46.3496 22.0693 45.6674 22.1259C44.3119 22.2386 42.9536 22.3125 41.5927 22.3477C40.8992 22.3662 40.2059 22.3748 39.5129 22.3735C36.7543 22.3713 33.9981 22.211 31.2578 21.8933C30.9611 21.8581 30.6645 21.8204 30.3678 21.7821C30.5978 21.8116 30.2006 21.7594 30.1202 21.7481C29.9316 21.7217 29.7431 21.6943 29.5545 21.6658C28.9216 21.5709 28.2924 21.454 27.6607 21.3515C26.8971 21.2258 26.1667 21.2887 25.476 21.6658C24.909 21.976 24.4501 22.4518 24.1605 23.0297C23.8626 23.6456 23.7739 24.3163 23.6407 24.9781C23.5074 25.6399 23.3 26.3521 23.3786 27.0315C23.5477 28.4979 24.5728 29.6895 26.0473 29.956C27.4345 30.2074 28.8292 30.4111 30.2276 30.5846C35.7212 31.2574 41.2711 31.3379 46.7818 30.8247C47.2305 30.7828 47.6787 30.7371 48.1262 30.6876C48.266 30.6723 48.4074 30.6884 48.5401 30.7348C48.6729 30.7812 48.7936 30.8566 48.8934 30.9557C48.9932 31.0548 49.0695 31.1749 49.1169 31.3073C49.1642 31.4397 49.1814 31.5811 49.167 31.7209L49.0275 33.0773C48.7463 35.8181 48.4652 38.5587 48.184 41.299C47.8907 44.1769 47.5955 47.0545 47.2984 49.9319C47.2146 50.7422 47.1308 51.5524 47.047 52.3624C46.9666 53.16 46.9552 53.9827 46.8038 54.7709C46.5649 56.0103 45.7258 56.7715 44.5015 57.0499C43.3798 57.3052 42.2339 57.4392 41.0836 57.4497C39.8083 57.4566 38.5336 57.4 37.2583 57.4069C35.897 57.4145 34.2295 57.2887 33.1786 56.2756C32.2553 55.3856 32.1277 53.9921 32.002 52.7872C31.8344 51.192 31.6682 49.5971 31.5036 48.0023L30.5796 39.1344L29.9819 33.3966C29.9718 33.3017 29.9618 33.208 29.9524 33.1125C29.8807 32.428 29.3961 31.758 28.6324 31.7926C27.9788 31.8215 27.2359 32.3771 27.3125 33.1125L27.7557 37.3664L28.672 46.1657C28.9331 48.6652 29.1935 51.165 29.4533 53.6653C29.5036 54.1442 29.5507 54.6244 29.6035 55.1034C29.8908 57.7205 31.8895 59.131 34.3646 59.5282C35.8102 59.7607 37.291 59.8085 38.758 59.8324C40.6386 59.8626 42.538 59.9348 44.3877 59.5942C47.1287 59.0914 49.1853 57.2611 49.4788 54.422C49.5626 53.6024 49.6464 52.7826 49.7302 51.9626C50.0088 49.2507 50.2871 46.5386 50.5649 43.8263L51.4737 34.9641L51.8904 30.9026C51.9112 30.7012 51.9962 30.5118 52.133 30.3625C52.2697 30.2132 52.4509 30.1119 52.6497 30.0736C53.4335 29.9208 54.1827 29.66 54.7402 29.0635C55.6277 28.1138 55.8043 26.8756 55.4906 25.6274ZM26.0071 26.5035C26.019 26.4979 25.997 26.6003 25.9876 26.6481C25.9857 26.5758 25.9895 26.5117 26.0071 26.5035ZM26.0831 27.0918C26.0894 27.0874 26.1083 27.1126 26.1278 27.1428C26.0982 27.1151 26.0794 27.0944 26.0825 27.0918H26.0831ZM26.1579 27.1905C26.185 27.2364 26.1994 27.2653 26.1579 27.1905V27.1905ZM26.3082 27.3125H26.3119C26.3119 27.3169 26.3188 27.3213 26.3214 27.3257C26.3172 27.3208 26.3126 27.3164 26.3075 27.3125H26.3082ZM52.6132 27.1302C52.3317 27.3979 51.9074 27.5224 51.4882 27.5846C46.7868 28.2823 42.0169 28.6355 37.264 28.4796C33.8624 28.3633 30.4967 27.9856 27.129 27.5098C26.799 27.4633 26.4414 27.403 26.2145 27.1597C25.7871 26.7009 25.997 25.777 26.1083 25.2226C26.2101 24.7148 26.405 24.0378 27.009 23.9656C27.9518 23.8549 29.0466 24.2528 29.9794 24.3942C31.1023 24.5656 32.2295 24.7028 33.3609 24.8059C38.1892 25.2459 43.0986 25.1774 47.9056 24.5337C48.7817 24.416 49.6548 24.2792 50.5246 24.1233C51.2996 23.9844 52.1588 23.7236 52.6271 24.5262C52.9482 25.073 52.991 25.8046 52.9413 26.4225C52.926 26.6917 52.8084 26.9448 52.6126 27.1302H52.6132Z" fill="#0D0C22"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M81.1302 40.1929C80.8556 40.7169 80.4781 41.1732 79.9978 41.5604C79.5175 41.9479 78.9571 42.2633 78.3166 42.5062C77.6761 42.7497 77.0315 42.9131 76.3835 42.9964C75.7352 43.0799 75.106 43.0727 74.4963 42.9735C73.8863 42.8749 73.3674 42.6737 72.9408 42.3695L73.4214 37.3779C73.8633 37.2261 74.4197 37.0703 75.0909 36.9107C75.7619 36.7513 76.452 36.6371 77.1613 36.5689C77.8705 36.5003 78.5412 36.5084 79.1744 36.5917C79.8068 36.6753 80.3065 36.8765 80.6725 37.1958C80.8707 37.378 81.0387 37.5754 81.176 37.7883C81.313 38.0011 81.3969 38.2214 81.4276 38.4493C81.5037 39.0875 81.4047 39.6687 81.1302 40.1929ZM74.153 29.5602C74.4734 29.3627 74.8585 29.1877 75.3083 29.0356C75.7581 28.8841 76.2195 28.7774 76.6923 28.7167C77.1648 28.6562 77.6262 28.6481 78.0763 28.6938C78.5258 28.7395 78.9228 28.8647 79.2659 29.0697C79.6089 29.2751 79.8643 29.5714 80.032 29.9586C80.1997 30.3464 80.2456 30.8365 80.1693 31.429C80.1083 31.9001 79.9211 32.2991 79.6089 32.6256C79.2963 32.9526 78.9147 33.2259 78.4652 33.4462C78.0154 33.6668 77.5388 33.8415 77.0356 33.9702C76.5321 34.0997 76.0477 34.1949 75.5828 34.2553C75.1176 34.3163 74.7137 34.3545 74.3706 34.3692C74.0273 34.3845 73.8021 34.3921 73.6956 34.3921L74.153 29.5602ZM83.6007 36.9676C83.3566 36.4361 83.0287 35.9689 82.6172 35.5658C82.2054 35.1633 81.717 34.8709 81.1531 34.6885C81.3969 34.491 81.6371 34.1795 81.8737 33.7539C82.1099 33.3288 82.3119 32.865 82.4796 32.3636C82.6474 31.8619 82.762 31.357 82.8229 30.8478C82.8836 30.3389 82.8607 29.902 82.7544 29.537C82.4947 28.6256 82.087 27.9114 81.5303 27.3946C80.9734 26.8782 80.3257 26.5211 79.586 26.3233C78.8462 26.1264 78.0304 26.0842 77.1383 26.1981C76.2462 26.312 75.3347 26.5361 74.4049 26.8704C74.4049 26.7946 74.4124 26.7148 74.4278 26.6312C74.4426 26.548 74.4504 26.4604 74.4504 26.369C74.4504 26.1411 74.3361 25.9439 74.1074 25.7765C73.8787 25.6093 73.6155 25.5107 73.3183 25.4801C73.0209 25.45 72.731 25.5142 72.4489 25.6738C72.1665 25.8334 71.9721 26.1264 71.8656 26.5511C71.7434 27.9189 71.6215 29.3398 71.4996 30.8134C71.3774 32.2875 71.248 33.7767 71.1107 35.2812C70.9735 36.7855 70.8362 38.2784 70.6989 39.7598C70.5616 41.2414 70.4244 42.6659 70.2871 44.0333C70.333 44.4436 70.4473 44.7629 70.6304 44.9907C70.8133 45.2189 71.0268 45.3556 71.2709 45.401C71.5147 45.4467 71.7704 45.4045 72.0371 45.2755C72.3038 45.1469 72.5365 44.9222 72.735 44.6032C73.3447 44.9375 74.0311 45.1541 74.7938 45.253C75.5561 45.3516 76.3298 45.3516 77.1157 45.253C77.9007 45.1541 78.6747 44.9682 79.4374 44.6943C80.1997 44.4211 80.8936 44.079 81.519 43.669C82.1441 43.2586 82.6703 42.7911 83.0975 42.2671C83.5244 41.7426 83.8065 41.1767 83.9437 40.5691C84.081 39.946 84.119 39.3231 84.0581 38.7C83.9971 38.0771 83.8445 37.5 83.6007 36.9676Z" fill="#0D0C23"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M105.915 49.0017C105.832 49.5031 105.713 50.0311 105.561 50.586C105.408 51.1403 105.229 51.6458 105.023 52.1018C104.818 52.5575 104.589 52.9256 104.337 53.207C104.085 53.488 103.815 53.606 103.525 53.5606C103.296 53.5297 103.151 53.3854 103.091 53.1274C103.029 52.8686 103.029 52.5497 103.091 52.17C103.151 51.7901 103.269 51.3607 103.445 50.8821C103.62 50.4035 103.834 49.9284 104.085 49.4577C104.337 48.9864 104.623 48.5347 104.943 48.1015C105.264 47.6686 105.599 47.3075 105.95 47.0189C106.026 47.11 106.06 47.3378 106.053 47.7028C106.045 48.0674 105.999 48.5006 105.915 49.0017ZM113.67 39.1097C113.464 38.8819 113.213 38.7529 112.915 38.7223C112.618 38.6919 112.317 38.859 112.012 39.2237C111.813 39.5883 111.562 39.9379 111.257 40.2722C110.952 40.6067 110.635 40.9103 110.307 41.1839C109.98 41.4572 109.667 41.6931 109.37 41.8903C109.072 42.0881 108.84 42.2324 108.672 42.3235C108.611 41.8374 108.576 41.3132 108.569 40.7507C108.561 40.1886 108.573 39.619 108.603 39.0415C108.649 38.2209 108.744 37.393 108.889 36.557C109.034 35.7213 109.244 34.9007 109.518 34.0951C109.518 33.67 109.419 33.3242 109.221 33.0582C109.022 32.7924 108.782 32.625 108.5 32.5567C108.218 32.4885 107.929 32.5264 107.631 32.6707C107.334 32.8153 107.078 33.0775 106.865 33.4569C106.682 33.9586 106.472 34.5207 106.236 35.1436C105.999 35.7667 105.732 36.4012 105.435 37.0469C105.138 37.6931 104.806 38.3197 104.44 38.9273C104.074 39.5354 103.674 40.075 103.239 40.5457C102.804 41.0168 102.331 41.3854 101.821 41.6512C101.31 41.9172 100.757 42.0349 100.162 42.0045C99.8876 41.9285 99.6893 41.7235 99.5675 41.3889C99.4453 41.0549 99.373 40.6368 99.3504 40.1354C99.3275 39.634 99.3504 39.0831 99.4189 38.4828C99.4877 37.8828 99.5791 37.2863 99.6934 36.6938C99.8078 36.101 99.9337 35.5389 100.071 35.0071C100.208 34.4753 100.337 34.0268 100.46 33.6622C100.643 33.2218 100.643 32.8529 100.46 32.5567C100.277 32.2604 100.025 32.0631 99.705 31.964C99.3846 31.8654 99.0489 31.8694 98.6983 31.9755C98.3474 32.0819 98.0958 32.3173 97.9435 32.682C97.684 33.3054 97.4475 34.004 97.2342 34.779C97.0206 35.5539 96.8491 36.3558 96.7197 37.1836C96.5896 38.0121 96.5171 38.8327 96.502 39.6456C96.5011 39.6985 96.5037 39.7488 96.5034 39.8014C96.1709 40.6848 95.854 41.3525 95.553 41.7992C95.1641 42.377 94.7253 42.6277 94.2375 42.5513C94.0236 42.4603 93.8832 42.2477 93.8147 41.9132C93.7453 41.5792 93.7227 41.1689 93.7453 40.6822C93.7688 40.1964 93.826 39.6456 93.9171 39.0299C94.0091 38.4146 94.1229 37.7764 94.2601 37.1154C94.3977 36.4541 94.5425 35.7899 94.6949 35.121C94.8472 34.4525 94.9845 33.8218 95.107 33.2291C95.0916 32.6973 94.9352 32.291 94.6377 32.0097C94.3405 31.7289 93.9247 31.6187 93.3913 31.6791C93.0253 31.8312 92.7542 32.029 92.579 32.2719C92.4034 32.5148 92.2623 32.8265 92.1558 33.2062C92.0946 33.404 92.0032 33.799 91.8813 34.3918C91.7591 34.984 91.603 35.6644 91.4123 36.4315C91.2217 37.1992 90.9967 38.0005 90.7376 38.8362C90.4781 39.6719 90.1885 40.4283 89.8684 41.1041C89.548 41.7801 89.1972 42.3235 88.8161 42.7338C88.4348 43.1438 88.023 43.3113 87.5807 43.2352C87.3366 43.1895 87.1805 42.9388 87.112 42.4831C87.0432 42.0271 87.0319 41.4653 87.0775 40.7964C87.1233 40.1279 87.2148 39.3946 87.352 38.5971C87.4893 37.7993 87.63 37.0434 87.7752 36.3289C87.92 35.6149 88.0535 34.984 88.1756 34.4372C88.2975 33.8901 88.3814 33.5254 88.4272 33.3433C88.4272 32.9026 88.3277 32.5495 88.1298 32.2832C87.9313 32.0178 87.6913 31.8503 87.4092 31.7818C87.1268 31.7136 86.8372 31.7514 86.54 31.8957C86.2426 32.0403 85.9872 32.3026 85.7736 32.682C85.6973 33.0923 85.598 33.5674 85.4761 34.1067C85.3539 34.6459 85.2361 35.2006 85.1218 35.7705C85.0074 36.3404 84.9003 36.8988 84.8014 37.4459C84.7021 37.993 84.6299 38.4716 84.584 38.8819C84.5536 39.2008 84.519 39.5923 84.4813 40.0556C84.443 40.5194 84.4238 41.0092 84.4238 41.5257C84.4238 42.0427 84.4618 42.5554 84.5385 43.0643C84.6145 43.5735 84.7518 44.0408 84.95 44.4659C85.1482 44.8915 85.4265 45.2408 85.7852 45.5144C86.1433 45.7879 86.5972 45.9397 87.1463 45.9704C87.7101 46.0005 88.202 45.9591 88.6217 45.8449C89.041 45.731 89.4221 45.5523 89.7654 45.3091C90.1084 45.0665 90.421 44.7776 90.7033 44.443C90.9851 44.1091 91.2637 43.7444 91.5383 43.3491C91.7974 43.9269 92.1329 44.3748 92.5447 44.694C92.9565 45.013 93.3913 45.2032 93.8486 45.2637C94.306 45.3241 94.7715 45.2602 95.2442 45.0699C95.7167 44.8803 96.1436 44.5573 96.5252 44.1012C96.7762 43.8216 97.0131 43.5038 97.2354 43.1525C97.3297 43.317 97.4301 43.4758 97.543 43.6224C97.9168 44.1091 98.424 44.443 99.0645 44.6255C99.7506 44.808 100.421 44.8386 101.077 44.7169C101.733 44.5954 102.358 44.3748 102.953 44.0559C103.548 43.7366 104.101 43.3532 104.612 42.9047C105.122 42.4565 105.568 41.9895 105.95 41.5028C105.934 41.8524 105.927 42.1832 105.927 42.4944C105.927 42.8061 105.919 43.1438 105.904 43.5088C105.141 44.0408 104.421 44.679 103.742 45.4233C103.064 46.1676 102.469 46.9616 101.958 47.8051C101.447 48.6483 101.047 49.5031 100.757 50.3691C100.467 51.2357 100.326 52.0445 100.334 52.7969C100.341 53.549 100.521 54.206 100.871 54.7681C101.222 55.3306 101.794 55.7331 102.587 55.9763C103.411 56.2348 104.135 56.242 104.76 55.9991C105.386 55.7559 105.931 55.3531 106.396 54.791C106.861 54.2289 107.242 53.549 107.54 52.7512C107.837 51.9534 108.073 51.1215 108.249 50.2555C108.424 49.3894 108.535 48.5379 108.58 47.7028C108.626 46.8668 108.626 46.1219 108.58 45.4687C109.892 44.9219 110.967 44.2305 111.806 43.3945C112.645 42.5594 113.338 41.6778 113.887 40.7507C114.055 40.5229 114.112 40.2493 114.059 39.9304C114.006 39.6111 113.876 39.3376 113.67 39.1097Z" fill="#0D0C23"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M142.53 37.6515C142.575 37.3022 142.644 36.9335 142.735 36.546C142.827 36.1585 142.941 35.7823 143.079 35.4177C143.216 35.0531 143.376 34.7379 143.559 34.4718C143.742 34.2061 143.937 34.0161 144.142 33.9019C144.348 33.7883 144.558 33.7995 144.771 33.936C145 34.0731 145.141 34.3617 145.195 34.8021C145.248 35.2433 145.195 35.7141 145.034 36.2155C144.874 36.7172 144.588 37.1879 144.177 37.6286C143.765 38.0696 143.208 38.3579 142.507 38.4947C142.476 38.2824 142.484 38.0011 142.53 37.6515ZM150.456 38.5857C150.204 38.5103 149.964 38.5025 149.735 38.5632C149.506 38.6239 149.361 38.7835 149.301 39.042C149.178 39.5281 148.984 40.0258 148.717 40.5347C148.45 41.0439 148.122 41.5262 147.734 41.9822C147.345 42.438 146.906 42.8408 146.418 43.1901C145.93 43.5397 145.419 43.7904 144.886 43.9422C144.351 44.1096 143.91 44.1284 143.559 43.9991C143.208 43.8705 142.93 43.6498 142.724 43.3384C142.518 43.027 142.369 42.6508 142.278 42.2101C142.186 41.7694 142.133 41.3137 142.118 40.8424C142.987 40.9034 143.761 40.7478 144.44 40.3751C145.118 40.0032 145.694 39.509 146.167 38.8937C146.639 38.2784 146.998 37.587 147.242 36.8195C147.485 36.0524 147.623 35.2887 147.653 34.5288C147.669 33.8146 147.562 33.2108 147.333 32.7169C147.105 32.2233 146.796 31.839 146.407 31.5658C146.018 31.2922 145.572 31.1326 145.069 31.0872C144.566 31.0415 144.054 31.11 143.536 31.2922C142.91 31.505 142.381 31.8506 141.946 32.3294C141.512 32.808 141.149 33.3629 140.86 33.9933C140.57 34.6239 140.341 35.3038 140.173 36.033C140.005 36.7626 139.883 37.4806 139.807 38.1873C139.739 38.8214 139.702 39.4278 139.689 40.013C139.657 40.0874 139.625 40.1588 139.59 40.2383C139.354 40.7782 139.079 41.3062 138.766 41.8226C138.454 42.3394 138.107 42.7725 137.726 43.1218C137.344 43.4714 136.948 43.5929 136.536 43.4865C136.292 43.426 136.159 43.1444 136.136 42.6433C136.113 42.1416 136.139 41.5187 136.216 40.7741C136.292 40.0298 136.38 39.2239 136.479 38.3579C136.578 37.4918 136.628 36.664 136.628 35.8737C136.628 35.1898 136.498 34.5329 136.239 33.9019C135.979 33.2718 135.625 32.7473 135.175 32.3294C134.725 31.9113 134.203 31.634 133.608 31.4975C133.013 31.3605 132.373 31.4518 131.687 31.7708C131 32.09 130.455 32.5382 130.051 33.1157C129.647 33.6934 129.277 34.3009 128.942 34.9391C128.819 34.4528 128.641 34.0011 128.404 33.583C128.167 33.1651 127.878 32.8005 127.535 32.4888C127.191 32.1776 126.806 31.9344 126.38 31.7595C125.953 31.5851 125.502 31.4975 125.03 31.4975C124.572 31.4975 124.149 31.5851 123.76 31.7595C123.371 31.9344 123.017 32.1583 122.696 32.4318C122.376 32.7056 122.087 33.013 121.827 33.3551C121.568 33.6969 121.339 34.0352 121.141 34.3692C121.11 33.9742 121.076 33.6286 121.038 33.332C121 33.0359 120.931 32.7852 120.832 32.5801C120.733 32.3748 120.592 32.2193 120.409 32.1129C120.226 32.0067 119.967 31.9532 119.632 31.9532C119.464 31.9532 119.296 31.9874 119.128 32.0556C118.96 32.1241 118.811 32.2193 118.682 32.3407C118.552 32.4627 118.453 32.6105 118.385 32.7852C118.316 32.9598 118.297 33.1614 118.327 33.3892C118.342 33.5566 118.385 33.7576 118.453 33.9933C118.522 34.2289 118.587 34.5369 118.648 34.9163C118.708 35.2962 118.758 35.756 118.796 36.2953C118.834 36.8349 118.846 37.4959 118.831 38.2784C118.815 39.0611 118.758 39.9763 118.659 41.0248C118.56 42.0733 118.403 43.289 118.19 44.6714C118.16 44.9907 118.282 45.2492 118.556 45.4467C118.831 45.6439 119.143 45.7578 119.494 45.7885C119.845 45.8188 120.177 45.7578 120.489 45.6063C120.802 45.4539 120.981 45.1882 121.027 44.8085C121.072 44.0943 121.16 43.3347 121.29 42.529C121.419 41.724 121.579 40.9262 121.77 40.1359C121.961 39.346 122.178 38.5938 122.422 37.8793C122.666 37.1651 122.937 36.5347 123.234 35.9876C123.532 35.4405 123.84 35.0039 124.161 34.6771C124.481 34.3504 124.816 34.187 125.167 34.187C125.594 34.187 125.926 34.3805 126.162 34.7679C126.398 35.1557 126.566 35.6536 126.666 36.2609C126.765 36.869 126.81 37.5341 126.803 38.2555C126.795 38.9773 126.765 39.6724 126.711 40.341C126.658 41.0098 126.597 41.606 126.528 42.1303C126.46 42.6545 126.41 43.0157 126.38 43.2129C126.38 43.5625 126.513 43.8395 126.78 44.0448C127.046 44.2498 127.344 44.3716 127.672 44.4095C128 44.4476 128.309 44.3866 128.598 44.227C128.888 44.0674 129.056 43.7982 129.102 43.4179C129.254 42.324 129.464 41.2264 129.731 40.1247C129.997 39.023 130.303 38.0355 130.646 37.1616C130.989 36.2878 131.37 35.5735 131.79 35.0189C132.209 34.4646 132.655 34.187 133.128 34.187C133.371 34.187 133.559 34.3544 133.688 34.6884C133.818 35.0227 133.883 35.4784 133.883 36.0559C133.883 36.4815 133.848 36.9184 133.78 37.3666C133.711 37.8148 133.631 38.2784 133.54 38.7569C133.448 39.2358 133.368 39.7256 133.299 40.227C133.231 40.7287 133.196 41.2527 133.196 41.7998C133.196 42.1797 133.235 42.6204 133.311 43.1218C133.387 43.6229 133.532 44.0983 133.745 44.5462C133.959 44.9947 134.252 45.3744 134.626 45.6858C135 45.9973 135.476 46.1531 136.056 46.1531C136.925 46.1531 137.695 45.9669 138.366 45.5947C139.037 45.2226 139.613 44.7365 140.093 44.1362C140.118 44.1047 140.141 44.0711 140.165 44.0399C140.202 44.1287 140.235 44.2227 140.276 44.3071C140.604 44.9756 141.05 45.4921 141.615 45.857C142.178 46.2216 142.842 46.4229 143.605 46.4611C144.367 46.4987 145.198 46.3581 146.098 46.0392C146.769 45.796 147.352 45.4921 147.848 45.1275C148.343 44.7628 148.789 44.3184 149.186 43.7941C149.583 43.2699 149.945 42.6658 150.273 41.9822C150.601 41.2981 150.932 40.5159 151.268 39.6342C151.329 39.3916 151.272 39.1751 151.097 38.9848C150.921 38.7951 150.708 38.6621 150.456 38.5857Z" fill="#0D0C23"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M162.887 36.0434C162.81 36.4918 162.707 36.986 162.578 37.525C162.448 38.0646 162.284 38.623 162.086 39.2004C161.888 39.7779 161.644 40.2984 161.354 40.7616C161.064 41.2254 160.733 41.5935 160.359 41.8671C159.985 42.1406 159.555 42.2546 159.066 42.2089C158.822 42.1788 158.635 42.0117 158.506 41.7075C158.376 41.4038 158.308 41.0161 158.3 40.545C158.292 40.0743 158.334 39.5575 158.426 38.9951C158.517 38.4333 158.658 37.8821 158.849 37.3426C159.04 36.8036 159.272 36.3056 159.547 35.8496C159.821 35.3939 160.138 35.0405 160.496 34.7898C160.854 34.5391 161.247 34.4217 161.674 34.4365C162.101 34.4518 162.559 34.6643 163.047 35.0747C163.016 35.2725 162.963 35.5954 162.887 36.0434ZM171.019 37.787C170.782 37.6656 170.538 37.6392 170.287 37.7075C170.035 37.7757 169.856 38.0076 169.749 38.4026C169.688 38.8283 169.551 39.3294 169.338 39.9069C169.124 40.4843 168.861 41.0317 168.548 41.5478C168.236 42.0646 167.877 42.494 167.473 42.8358C167.069 43.1778 166.638 43.3337 166.181 43.3028C165.799 43.2727 165.532 43.079 165.38 42.7218C165.227 42.3647 165.147 41.9168 165.14 41.3769C165.132 40.838 165.186 40.2301 165.3 39.5538C165.414 38.8777 165.552 38.2054 165.712 37.5363C165.872 36.868 166.036 36.2258 166.204 35.6105C166.371 34.9951 166.508 34.4747 166.616 34.0493C166.738 33.6693 166.699 33.3466 166.501 33.0803C166.303 32.8149 166.055 32.6246 165.758 32.5107C165.46 32.3967 165.159 32.3664 164.854 32.4196C164.549 32.4728 164.351 32.6362 164.259 32.9094C163.359 32.1345 162.494 31.7166 161.663 31.6559C160.831 31.5952 160.065 31.7776 159.364 32.203C158.662 32.6284 158.041 33.2437 157.5 34.0493C156.958 34.8549 156.52 35.7322 156.184 36.6818C155.849 37.6314 155.639 38.6004 155.555 39.5879C155.471 40.5757 155.536 41.4761 155.75 42.289C155.963 43.1018 156.34 43.7669 156.882 44.283C157.423 44.7998 158.159 45.0583 159.089 45.0583C159.501 45.0583 159.898 44.9747 160.279 44.8076C160.66 44.6401 161.011 44.4426 161.331 44.2148C161.651 43.9869 161.933 43.7475 162.178 43.4968C162.421 43.2461 162.612 43.0373 162.749 42.8699C162.856 43.417 163.032 43.8808 163.276 44.2605C163.519 44.6401 163.798 44.9521 164.111 45.1948C164.423 45.4376 164.751 45.6164 165.094 45.7306C165.437 45.8445 165.769 45.9015 166.089 45.9015C166.806 45.9015 167.477 45.6583 168.102 45.1719C168.727 44.6861 169.288 44.0893 169.784 43.3829C170.279 42.6762 170.687 41.9319 171.007 41.1491C171.328 40.3666 171.541 39.6715 171.648 39.0634C171.755 38.8355 171.735 38.5964 171.591 38.3457C171.446 38.095 171.255 37.909 171.019 37.787Z" fill="#0D0C23"/>
<path fill-rule="evenodd" clip-rule="evenodd" d="M212.194 50.3701C212.064 50.8866 211.862 51.3238 211.587 51.6806C211.313 52.0377 210.97 52.2239 210.558 52.2393C210.299 52.2543 210.101 52.1175 209.963 51.8289C209.826 51.5401 209.731 51.1679 209.678 50.7122C209.624 50.2562 209.601 49.747 209.609 49.1849C209.616 48.6227 209.639 48.0681 209.678 47.521C209.715 46.9742 209.761 46.4647 209.815 45.9939C209.868 45.5226 209.91 45.1586 209.94 44.9C210.459 44.9608 210.89 45.1846 211.233 45.5723C211.576 45.9598 211.839 46.4193 212.022 46.9514C212.205 47.4831 212.312 48.0568 212.343 48.6722C212.373 49.2875 212.323 49.8534 212.194 50.3701ZM203.913 50.3701C203.783 50.8866 203.581 51.3238 203.307 51.6806C203.032 52.0377 202.689 52.2239 202.277 52.2393C202.018 52.2543 201.82 52.1175 201.683 51.8289C201.545 51.5401 201.45 51.1679 201.397 50.7122C201.343 50.2562 201.32 49.747 201.328 49.1849C201.336 48.6227 201.358 48.0681 201.397 47.521C201.434 46.9742 201.48 46.4647 201.534 45.9939C201.587 45.5226 201.629 45.1586 201.66 44.9C202.178 44.9608 202.609 45.1846 202.952 45.5723C203.295 45.9598 203.558 46.4193 203.741 46.9514C203.924 47.4831 204.031 48.0568 204.062 48.6722C204.092 49.2875 204.042 49.8534 203.913 50.3701ZM195.415 37.4241C195.399 37.7884 195.365 38.1114 195.312 38.3925C195.258 38.6741 195.186 38.8522 195.095 38.9283C194.927 38.8369 194.721 38.6018 194.477 38.2216C194.233 37.8419 194.042 37.4122 193.905 36.9336C193.768 36.4551 193.725 35.9843 193.779 35.5205C193.832 35.0573 194.073 34.6967 194.5 34.4379C194.667 34.3468 194.812 34.3809 194.934 34.5405C195.056 34.7001 195.155 34.9318 195.232 35.2357C195.308 35.5399 195.361 35.8892 195.392 36.2842C195.422 36.6795 195.43 37.0591 195.415 37.4241ZM193.39 41.9711C193.154 42.2215 192.89 42.4381 192.601 42.6206C192.311 42.803 192.014 42.9398 191.709 43.0309C191.404 43.1223 191.129 43.1448 190.885 43.0991C190.199 42.9627 189.673 42.666 189.307 42.2103C188.941 41.7545 188.708 41.219 188.609 40.6037C188.51 39.9881 188.521 39.3308 188.644 38.6319C188.765 37.933 188.971 37.2835 189.261 36.6832C189.551 36.0829 189.902 35.5662 190.313 35.1333C190.725 34.7001 191.175 34.4306 191.663 34.3239C191.48 35.0989 191.419 35.9007 191.48 36.7286C191.541 37.5568 191.739 38.3355 192.075 39.0648C192.288 39.506 192.544 39.9082 192.841 40.2729C193.139 40.6378 193.501 40.9492 193.928 41.2075C193.806 41.466 193.626 41.7204 193.39 41.9711ZM218.702 37.6519C218.747 37.3026 218.816 36.9336 218.908 36.5462C218.999 36.159 219.114 35.7828 219.251 35.4181C219.388 35.0532 219.548 34.738 219.731 34.4723C219.914 34.2065 220.108 34.0163 220.314 33.9024C220.52 33.7884 220.73 33.7997 220.943 33.9365C221.172 34.0735 221.313 34.3621 221.367 34.8025C221.42 35.2435 221.367 35.7142 221.207 36.2159C221.046 36.7173 220.761 37.1884 220.349 37.6288C219.937 38.07 219.38 38.3583 218.679 38.4951C218.648 38.2826 218.656 38.0015 218.702 37.6519ZM227.921 37.6519C227.966 37.3026 228.035 36.9336 228.126 36.5462C228.218 36.159 228.332 35.7828 228.47 35.4181C228.607 35.0532 228.767 34.738 228.95 34.4723C229.133 34.2065 229.328 34.0163 229.533 33.9024C229.739 33.7884 229.949 33.7997 230.162 33.9365C230.391 34.0735 230.532 34.3621 230.586 34.8025C230.639 35.2435 230.586 35.7142 230.425 36.2159C230.265 36.7173 229.979 37.1884 229.568 37.6288C229.156 38.07 228.599 38.3583 227.898 38.4951C227.867 38.2826 227.875 38.0015 227.921 37.6519ZM236.488 38.9852C236.312 38.7955 236.099 38.6625 235.847 38.5862C235.595 38.5104 235.355 38.5029 235.126 38.5636C234.897 38.6244 234.752 38.784 234.692 39.0422C234.57 39.5286 234.375 40.0262 234.108 40.5349C233.841 41.0444 233.514 41.5267 233.125 41.9824C232.736 42.4381 232.297 42.8412 231.81 43.1905C231.321 43.5401 230.81 43.7908 230.277 43.9423C229.743 44.1101 229.301 44.1289 228.95 43.9996C228.599 43.8706 228.321 43.6503 228.115 43.3389C227.909 43.0271 227.761 42.6512 227.669 42.2103C227.578 41.7699 227.524 41.3142 227.509 40.8428C228.378 40.9038 229.152 40.7483 229.831 40.3755C230.509 40.0034 231.085 39.5092 231.558 38.8939C232.031 38.2788 232.389 37.5874 232.633 36.82C232.877 36.0526 233.014 35.2892 233.045 34.5293C233.06 33.815 232.953 33.211 232.724 32.7171C232.496 32.2235 232.187 31.8395 231.798 31.5662C231.409 31.2924 230.963 31.133 230.46 31.0874C229.957 31.0417 229.445 31.1105 228.927 31.2924C228.302 31.5055 227.772 31.851 227.338 32.3296C226.903 32.8085 226.54 33.3634 226.251 33.9934C225.961 34.6244 225.732 35.3039 225.564 36.0335C225.396 36.7627 225.274 37.481 225.199 38.1874C225.124 38.873 225.084 39.5292 225.075 40.1572C225.017 40.2824 224.956 40.4082 224.889 40.5349C224.622 41.0444 224.295 41.5267 223.906 41.9824C223.517 42.4381 223.078 42.8412 222.591 43.1905C222.102 43.5401 221.592 43.7908 221.058 43.9423C220.524 44.1101 220.082 44.1289 219.731 43.9996C219.38 43.8706 219.102 43.6503 218.896 43.3389C218.691 43.0271 218.542 42.6512 218.45 42.2103C218.359 41.7699 218.305 41.3142 218.29 40.8428C219.159 40.9038 219.933 40.7483 220.612 40.3755C221.29 40.0034 221.866 39.5092 222.339 38.8939C222.811 38.2788 223.17 37.5874 223.414 36.82C223.658 36.0526 223.795 35.2892 223.826 34.5293C223.841 33.815 223.734 33.211 223.506 32.7171C223.277 32.2235 222.968 31.8395 222.579 31.5662C222.19 31.2924 221.744 31.133 221.241 31.0874C220.738 31.0417 220.227 31.1105 219.708 31.2924C219.083 31.5055 218.553 31.851 218.119 32.3296C217.684 32.8085 217.321 33.3634 217.032 33.9934C216.742 34.6244 216.513 35.3039 216.346 36.0335C216.178 36.7627 216.056 37.481 215.98 38.1874C215.936 38.5859 215.907 38.9722 215.886 39.3516C215.739 39.4765 215.595 39.6023 215.442 39.7258C214.916 40.1514 214.363 40.5349 213.784 40.8769C213.204 41.219 212.601 41.5001 211.977 41.7204C211.351 41.9408 210.71 42.0738 210.055 42.1192L211.473 26.9847C211.565 26.6655 211.519 26.3847 211.336 26.1415C211.153 25.8983 210.916 25.7312 210.627 25.6401C210.337 25.5488 210.028 25.5566 209.7 25.6627C209.372 25.7694 209.102 26.0126 208.888 26.3919C208.781 26.9697 208.671 27.7597 208.557 28.7625C208.442 29.7653 208.328 30.8595 208.213 32.0448C208.099 33.23 207.985 34.4532 207.87 35.7142C207.756 36.9759 207.657 38.1533 207.573 39.2472C207.569 39.2958 207.566 39.3398 207.562 39.3878C207.429 39.5005 207.299 39.6142 207.161 39.7258C206.635 40.1514 206.082 40.5349 205.503 40.8769C204.923 41.219 204.321 41.5001 203.696 41.7204C203.07 41.9408 202.429 42.0738 201.774 42.1192L203.192 26.9847C203.284 26.6655 203.238 26.3847 203.055 26.1415C202.872 25.8983 202.635 25.7312 202.346 25.6401C202.056 25.5488 201.747 25.5566 201.419 25.6627C201.091 25.7694 200.821 26.0126 200.607 26.3919C200.501 26.9697 200.39 27.7597 200.276 28.7625C200.161 29.7653 200.047 30.8595 199.933 32.0448C199.818 33.23 199.704 34.4532 199.589 35.7142C199.475 36.9759 199.376 38.1533 199.292 39.2472C199.29 39.2692 199.289 39.2891 199.287 39.3111C199.048 39.4219 198.786 39.519 198.503 39.6006C198.213 39.6844 197.885 39.7339 197.519 39.7489C197.58 39.4751 197.63 39.1712 197.668 38.8369C197.706 38.5029 197.737 38.1533 197.76 37.7884C197.782 37.4241 197.79 37.0591 197.782 36.6945C197.774 36.3296 197.755 35.9956 197.725 35.6914C197.649 35.0385 197.508 34.4191 197.302 33.8338C197.096 33.2491 196.818 32.7593 196.467 32.3637C196.116 31.9687 195.678 31.7027 195.151 31.5662C194.626 31.4294 194.012 31.4748 193.31 31.7027C192.273 31.5662 191.339 31.6613 190.508 31.9878C189.677 32.3149 188.956 32.7894 188.346 33.4122C187.736 34.0357 187.237 34.7684 186.848 35.6119C186.459 36.4551 186.2 37.3214 186.07 38.21C186.015 38.5868 185.988 38.9618 185.98 39.336C185.744 39.8177 185.486 40.2388 185.201 40.5921C184.797 41.0935 184.377 41.5038 183.943 41.8228C183.508 42.142 183.077 42.3852 182.65 42.5523C182.223 42.7198 181.842 42.8337 181.507 42.8941C181.11 42.9702 180.729 42.978 180.363 42.917C179.997 42.8565 179.661 42.6816 179.357 42.3927C179.112 42.1802 178.925 41.8381 178.796 41.3671C178.666 40.896 178.59 40.3608 178.567 39.7602C178.544 39.1599 178.567 38.533 178.636 37.8798C178.705 37.2266 178.822 36.6072 178.99 36.0222C179.158 35.4372 179.371 34.913 179.631 34.4492C179.89 33.9862 180.195 33.6554 180.546 33.4579C180.744 33.4886 180.866 33.606 180.912 33.811C180.958 34.0163 180.969 34.2595 180.946 34.5405C180.923 34.8219 180.889 35.1105 180.843 35.4066C180.797 35.703 180.775 35.9502 180.775 36.1474C180.851 36.5577 180.999 36.877 181.221 37.1048C181.441 37.3327 181.69 37.466 181.964 37.5036C182.239 37.5417 182.509 37.4773 182.776 37.3098C183.043 37.143 183.26 36.877 183.428 36.512C183.443 36.5274 183.466 36.5349 183.497 36.5349L183.817 33.6404C183.909 33.2451 183.847 32.8958 183.634 32.5919C183.42 32.288 183.138 32.113 182.788 32.0676C182.345 31.4294 181.747 31.0914 180.992 31.0532C180.237 31.0154 179.463 31.2623 178.67 31.7941C178.182 32.144 177.751 32.626 177.378 33.2413C177.004 33.857 176.699 34.5405 176.463 35.2926C176.226 36.0448 176.058 36.8391 175.959 37.6748C175.86 38.5104 175.841 39.3236 175.902 40.1133C175.963 40.9038 176.104 41.6484 176.325 42.347C176.546 43.0462 176.855 43.6312 177.252 44.102C177.587 44.5123 177.968 44.8127 178.395 45.0027C178.822 45.1927 179.268 45.3101 179.734 45.3558C180.199 45.4012 180.66 45.3821 181.118 45.2988C181.575 45.2155 182.01 45.0978 182.421 44.9454C182.955 44.7482 183.505 44.4972 184.069 44.1933C184.633 43.8897 185.174 43.5248 185.693 43.0991C185.966 42.8753 186.228 42.6313 186.482 42.3696C186.598 42.6553 186.727 42.9317 186.882 43.1905C187.294 43.8741 187.85 44.429 188.552 44.8544C189.253 45.2797 190.115 45.4844 191.137 45.4697C192.235 45.4544 193.249 45.1774 194.18 44.6378C195.11 44.0988 195.872 43.3042 196.467 42.256C197.358 42.256 198.234 42.1096 199.096 41.819C199.089 41.911 199.081 42.0079 199.075 42.0966C199.014 42.9019 198.983 43.4487 198.983 43.7376C198.968 44.239 198.934 44.8581 198.88 45.5949C198.827 46.332 198.793 47.1069 198.778 47.9198C198.763 48.7326 198.793 49.5532 198.869 50.3817C198.945 51.2096 199.105 51.962 199.349 52.6383C199.593 53.3141 199.94 53.8878 200.39 54.3591C200.84 54.8299 201.431 55.1112 202.163 55.2023C202.941 55.3084 203.612 55.1717 204.176 54.792C204.74 54.412 205.198 53.8918 205.549 53.2308C205.899 52.5695 206.147 51.8061 206.292 50.9401C206.437 50.074 206.479 49.2039 206.418 48.3301C206.357 47.4562 206.196 46.6321 205.937 45.8575C205.678 45.0822 205.319 44.444 204.862 43.9423C205.137 43.8669 205.465 43.7226 205.846 43.5095C206.227 43.2969 206.62 43.0575 207.024 42.7915C207.123 42.7261 207.221 42.6573 207.32 42.5902C207.283 43.1286 207.264 43.5126 207.264 43.7376C207.249 44.239 207.215 44.8581 207.161 45.5949C207.108 46.332 207.073 47.1069 207.058 47.9198C207.043 48.7326 207.073 49.5532 207.15 50.3817C207.226 51.2096 207.386 51.962 207.63 52.6383C207.874 53.3141 208.221 53.8878 208.671 54.3591C209.121 54.8299 209.712 55.1112 210.444 55.2023C211.221 55.3084 211.892 55.1717 212.457 54.792C213.021 54.412 213.478 53.8918 213.83 53.2308C214.18 52.5695 214.428 51.8061 214.573 50.9401C214.718 50.074 214.759 49.2039 214.699 48.3301C214.637 47.4562 214.477 46.6321 214.218 45.8575C213.959 45.0822 213.601 44.444 213.143 43.9423C213.418 43.8669 213.745 43.7226 214.127 43.5095C214.508 43.2969 214.9 43.0575 215.305 42.7915C215.515 42.6533 215.724 42.5107 215.932 42.3641C216.01 43.1072 216.179 43.759 216.448 44.3073C216.776 44.9761 217.222 45.4925 217.787 45.8575C218.351 46.2218 219.014 46.4234 219.777 46.4612C220.539 46.4988 221.37 46.3586 222.271 46.0393C222.941 45.7965 223.525 45.4925 224.02 45.1279C224.516 44.763 224.962 44.3185 225.358 43.7946C225.381 43.7642 225.403 43.7313 225.425 43.7006C225.496 43.9134 225.574 44.1179 225.667 44.3073C225.995 44.9761 226.441 45.4925 227.006 45.8575C227.569 46.2218 228.233 46.4234 228.996 46.4612C229.758 46.4988 230.589 46.3586 231.489 46.0393C232.16 45.7965 232.744 45.4925 233.239 45.1279C233.735 44.763 234.181 44.3185 234.577 43.7946C234.974 43.27 235.336 42.666 235.664 41.9824C235.992 41.2985 236.323 40.5164 236.659 39.6347C236.72 39.3918 236.663 39.1752 236.488 38.9852Z" fill="#0D0C23"/>
</svg>`;
var paypal = `
<svg xmlns="http://www.w3.org/2000/svg" width="150" height="40">
<path fill="#253B80" d="M46.211 6.749h-6.839a.95.95 0 0 0-.939.802l-2.766 17.537a.57.57 0 0 0 .564.658h3.265a.95.95 0 0 0 .939-.803l.746-4.73a.95.95 0 0 1 .938-.803h2.165c4.505 0 7.105-2.18 7.784-6.5.306-1.89.013-3.375-.872-4.415-.972-1.142-2.696-1.746-4.985-1.746zM47 13.154c-.374 2.454-2.249 2.454-4.062 2.454h-1.032l.724-4.583a.57.57 0 0 1 .563-.481h.473c1.235 0 2.4 0 3.002.704.359.42.469 1.044.332 1.906zM66.654 13.075h-3.275a.57.57 0 0 0-.563.481l-.145.916-.229-.332c-.709-1.029-2.29-1.373-3.868-1.373-3.619 0-6.71 2.741-7.312 6.586-.313 1.918.132 3.752 1.22 5.031.998 1.176 2.426 1.666 4.125 1.666 2.916 0 4.533-1.875 4.533-1.875l-.146.91a.57.57 0 0 0 .562.66h2.95a.95.95 0 0 0 .939-.803l1.77-11.209a.568.568 0 0 0-.561-.658zm-4.565 6.374c-.316 1.871-1.801 3.127-3.695 3.127-.951 0-1.711-.305-2.199-.883-.484-.574-.668-1.391-.514-2.301.295-1.855 1.805-3.152 3.67-3.152.93 0 1.686.309 2.184.892.499.589.697 1.411.554 2.317zM84.096 13.075h-3.291a.954.954 0 0 0-.787.417l-4.539 6.686-1.924-6.425a.953.953 0 0 0-.912-.678h-3.234a.57.57 0 0 0-.541.754l3.625 10.638-3.408 4.811a.57.57 0 0 0 .465.9h3.287a.949.949 0 0 0 .781-.408l10.946-15.8a.57.57 0 0 0-.468-.895z"/>
<path fill="#179BD7" d="M94.992 6.749h-6.84a.95.95 0 0 0-.938.802l-2.766 17.537a.569.569 0 0 0 .562.658h3.51a.665.665 0 0 0 .656-.562l.785-4.971a.95.95 0 0 1 .938-.803h2.164c4.506 0 7.105-2.18 7.785-6.5.307-1.89.012-3.375-.873-4.415-.971-1.142-2.694-1.746-4.983-1.746zm.789 6.405c-.373 2.454-2.248 2.454-4.062 2.454h-1.031l.725-4.583a.568.568 0 0 1 .562-.481h.473c1.234 0 2.4 0 3.002.704.359.42.468 1.044.331 1.906zM115.434 13.075h-3.273a.567.567 0 0 0-.562.481l-.145.916-.23-.332c-.709-1.029-2.289-1.373-3.867-1.373-3.619 0-6.709 2.741-7.311 6.586-.312 1.918.131 3.752 1.219 5.031 1 1.176 2.426 1.666 4.125 1.666 2.916 0 4.533-1.875 4.533-1.875l-.146.91a.57.57 0 0 0 .564.66h2.949a.95.95 0 0 0 .938-.803l1.771-11.209a.571.571 0 0 0-.565-.658zm-4.565 6.374c-.314 1.871-1.801 3.127-3.695 3.127-.949 0-1.711-.305-2.199-.883-.484-.574-.666-1.391-.514-2.301.297-1.855 1.805-3.152 3.67-3.152.93 0 1.686.309 2.184.892.501.589.699 1.411.554 2.317zM119.295 7.23l-2.807 17.858a.569.569 0 0 0 .562.658h2.822c.469 0 .867-.34.939-.803l2.768-17.536a.57.57 0 0 0-.562-.659h-3.16a.571.571 0 0 0-.562.482z"/>
<path fill="#253B80" d="M7.266 29.154l.523-3.322-1.165-.027H1.061L4.927 1.292a.316.316 0 0 1 .314-.268h9.38c3.114 0 5.263.648 6.385 1.927.526.6.861 1.227 1.023 1.917.17.724.173 1.589.007 2.644l-.012.077v.676l.526.298a3.69 3.69 0 0 1 1.065.812c.45.513.741 1.165.864 1.938.127.795.085 1.741-.123 2.812-.24 1.232-.628 2.305-1.152 3.183a6.547 6.547 0 0 1-1.825 2c-.696.494-1.523.869-2.458 1.109-.906.236-1.939.355-3.072.355h-.73c-.522 0-1.029.188-1.427.525a2.21 2.21 0 0 0-.744 1.328l-.055.299-.924 5.855-.042.215c-.011.068-.03.102-.058.125a.155.155 0 0 1-.096.035H7.266z"/>
<path fill="#179BD7" d="M23.048 7.667c-.028.179-.06.362-.096.55-1.237 6.351-5.469 8.545-10.874 8.545H9.326c-.661 0-1.218.48-1.321 1.132L6.596 26.83l-.399 2.533a.704.704 0 0 0 .695.814h4.881c.578 0 1.069-.42 1.16-.99l.048-.248.919-5.832.059-.32c.09-.572.582-.992 1.16-.992h.73c4.729 0 8.431-1.92 9.513-7.476.452-2.321.218-4.259-.978-5.622a4.667 4.667 0 0 0-1.336-1.03z"/>
<path fill="#222D65" d="M21.754 7.151a9.757 9.757 0 0 0-1.203-.267 15.284 15.284 0 0 0-2.426-.177h-7.352a1.172 1.172 0 0 0-1.159.992L8.05 17.605l-.045.289a1.336 1.336 0 0 1 1.321-1.132h2.752c5.405 0 9.637-2.195 10.874-8.545.037-.188.068-.371.096-.55a6.594 6.594 0 0 0-1.017-.429 9.045 9.045 0 0 0-.277-.087z"/>
<path fill="#253B80" d="M9.614 7.699a1.169 1.169 0 0 1 1.159-.991h7.352c.871 0 1.684.057 2.426.177a9.757 9.757 0 0 1 1.481.353c.365.121.704.264 1.017.429.368-2.347-.003-3.945-1.272-5.392C20.378.682 17.853 0 14.622 0h-9.38c-.66 0-1.223.48-1.325 1.133L.01 25.898a.806.806 0 0 0 .795.932h5.791l1.454-9.225 1.564-9.906z"/>
</svg>`;
/*! Bundled license information:

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
